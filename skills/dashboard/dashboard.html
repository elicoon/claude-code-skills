<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>dev-org // backlog dashboard</title>
<link rel="icon" href="data:,">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&family=Source+Serif+4:ital,opsz,wght@0,8..60,300;0,8..60,400;0,8..60,600;1,8..60,400&display=swap" rel="stylesheet">
<style>
  *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

  :root {
    --bg-void: #080b10;
    --bg-primary: #0d1117;
    --bg-surface: #131920;
    --bg-elevated: #1a222c;
    --border: #222d3a;
    --border-subtle: #1a2332;
    --text-primary: #d4dce8;
    --text-secondary: #6b7d93;
    --text-dim: #3d4f63;

    --status-progress: #58a6ff;
    --status-blocked: #f85149;
    --status-notstarted: #7a8da2;
    --status-done: #3fb950;
    --status-draft: #3d4f63;

    --p1: #f85149;
    --p2: #d29922;
    --p3: #58a6ff;
    --p4: #7a8da2;
    --p5: #3d4f63;

    --font-mono: 'JetBrains Mono', 'SF Mono', monospace;
    --font-serif: 'Source Serif 4', Georgia, serif;

    --glow-blue: 0 0 20px rgba(88,166,255,0.15);
    --glow-red: 0 0 20px rgba(248,81,73,0.15);
    --glow-green: 0 0 12px rgba(63,185,80,0.1);

    --status-queued: #d29922;
    --status-rework: #bc8cff;
    --glow-amber: 0 0 12px rgba(210,153,34,0.15);
  }

  html { font-size: 87.5%; /* 14px at default 16px base, preserves user font prefs */ }

  body {
    background: var(--bg-void);
    color: var(--text-primary);
    font-family: var(--font-mono);
    min-height: 100vh;
    position: relative;
    overflow-x: hidden;
  }

  /* Scanline overlay */
  body::after {
    content: '';
    position: fixed;
    inset: 0;
    background: repeating-linear-gradient(
      0deg,
      transparent,
      transparent 2px,
      rgba(0,0,0,0.03) 2px,
      rgba(0,0,0,0.03) 4px
    );
    pointer-events: none;
    z-index: 50;
  }

  @media (prefers-reduced-motion: reduce) {
    *, *::before, *::after {
      animation-duration: 0.01ms !important;
      animation-iteration-count: 1 !important;
      transition-duration: 0.01ms !important;
    }
  }

  /* ── HEADER ── */
  .header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 20px 32px;
    border-bottom: 1px solid var(--border-subtle);
    background: linear-gradient(180deg, rgba(13,17,23,0.9) 0%, var(--bg-void) 100%);
    position: sticky;
    top: 0;
    z-index: 100;
    backdrop-filter: blur(12px);
  }

  .header-left {
    display: flex;
    align-items: center;
    gap: 16px;
  }

  .logo-mark {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: var(--status-progress);
    box-shadow: 0 0 8px var(--status-progress), 0 0 20px rgba(88,166,255,0.3);
    animation: pulse-glow 3s ease-in-out infinite;
  }

  @keyframes pulse-glow {
    0%, 100% { opacity: 1; box-shadow: 0 0 8px var(--status-progress), 0 0 20px rgba(88,166,255,0.3); }
    50% { opacity: 0.7; box-shadow: 0 0 4px var(--status-progress), 0 0 10px rgba(88,166,255,0.15); }
  }

  .header-title {
    font-family: var(--font-serif);
    font-size: 1.15rem;
    font-weight: 600;
    letter-spacing: -0.02em;
    color: var(--text-primary);
  }

  .header-title span {
    color: var(--text-dim);
    font-weight: 300;
  }

  .header-meta {
    font-size: 0.72rem;
    color: var(--text-dim);
    letter-spacing: 0.08em;
    text-transform: uppercase;
    display: flex;
    align-items: center;
    gap: 16px;
  }

  .data-source {
    display: inline-flex;
    align-items: center;
    gap: 5px;
    font-size: 0.62rem;
    letter-spacing: 0.06em;
    padding: 2px 8px;
    border-radius: 3px;
    text-transform: uppercase;
  }

  .data-source.live {
    background: rgba(63,185,80,0.1);
    color: var(--status-done);
    border: 1px solid rgba(63,185,80,0.2);
  }

  .data-source.embedded {
    background: rgba(210,153,34,0.1);
    color: var(--p2);
    border: 1px solid rgba(210,153,34,0.2);
  }

  .data-source-dot {
    width: 5px;
    height: 5px;
    border-radius: 50%;
  }

  .data-source.live .data-source-dot {
    background: var(--status-done);
    box-shadow: 0 0 4px var(--status-done);
  }

  .data-source.embedded .data-source-dot {
    background: var(--p2);
  }

  .refresh-btn {
    background: none;
    border: 1px solid var(--border);
    color: var(--text-dim);
    font-family: var(--font-mono);
    font-size: 0.62rem;
    letter-spacing: 0.06em;
    text-transform: uppercase;
    padding: 3px 10px;
    border-radius: 3px;
    cursor: pointer;
    transition: color 0.15s ease, border-color 0.15s ease;
  }

  .refresh-btn:hover {
    color: var(--text-secondary);
    border-color: var(--text-dim);
  }

  .refresh-btn:active {
    color: var(--status-progress);
    border-color: var(--status-progress);
  }

  .refresh-btn.spinning {
    color: var(--status-progress);
    border-color: var(--status-progress);
    pointer-events: none;
  }

  /* Loading state */
  .loading-overlay {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 80px 32px;
    text-align: center;
    gap: 16px;
  }

  .loading-spinner {
    width: 24px;
    height: 24px;
    border: 2px solid var(--border);
    border-top-color: var(--status-progress);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  .loading-text {
    font-size: 0.78rem;
    color: var(--text-dim);
    letter-spacing: 0.06em;
    text-transform: uppercase;
  }

  .error-banner {
    background: rgba(248,81,73,0.08);
    border: 1px solid rgba(248,81,73,0.2);
    color: var(--status-blocked);
    font-size: 0.72rem;
    padding: 10px 18px;
    margin: 0 32px 16px;
    border-radius: 4px;
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .error-banner-dismiss {
    margin-left: auto;
    background: none;
    border: none;
    color: var(--status-blocked);
    cursor: pointer;
    font-size: 0.9rem;
    opacity: 0.6;
  }

  .error-banner-dismiss:hover { opacity: 1; }

  /* ── TAB BAR ── */
  .tab-bar {
    display: flex;
    gap: 0;
    padding: 0 32px;
    background: var(--bg-void);
    border-bottom: 1px solid var(--border-subtle);
  }

  .tab {
    padding: 14px 24px;
    font-family: var(--font-mono);
    font-size: 0.78rem;
    font-weight: 400;
    letter-spacing: 0.06em;
    text-transform: uppercase;
    color: var(--text-dim);
    cursor: pointer;
    border: none;
    background: none;
    position: relative;
    transition: color 0.25s ease;
  }

  .tab:hover { color: var(--text-secondary); }

  .tab.active {
    color: var(--text-primary);
  }

  .tab.active::after {
    content: '';
    position: absolute;
    bottom: -1px;
    left: 24px;
    right: 24px;
    height: 1px;
    background: var(--status-progress);
    box-shadow: 0 0 8px rgba(88,166,255,0.4);
  }

  .tab-label {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .tab-letter {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 18px;
    height: 18px;
    border-radius: 3px;
    border: 1px solid var(--border);
    font-size: 0.65rem;
    font-weight: 600;
    opacity: 0.5;
  }

  .tab.active .tab-letter {
    border-color: var(--status-progress);
    color: var(--status-progress);
    opacity: 1;
  }

  /* ── VIEW CONTAINERS ── */
  .view { display: none; padding: 28px 32px; animation: fadeIn 0.3s ease; }
  .view.active { display: block; }

  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(4px); }
    to { opacity: 1; transform: translateY(0); }
  }

  /* ── SUMMARY CARDS ── */
  .summary-row {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 12px;
    margin-bottom: 28px;
  }

  .summary-card {
    background: var(--bg-surface);
    border: 1px solid var(--border-subtle);
    border-radius: 6px;
    padding: 16px 18px;
    position: relative;
    overflow: hidden;
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
  }

  .summary-card:hover {
    border-color: var(--border);
  }

  .summary-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 2px;
  }

  .summary-card[data-status="progress"]::before { background: var(--status-progress); box-shadow: var(--glow-blue); }
  .summary-card[data-status="blocked"]::before { background: var(--status-blocked); box-shadow: var(--glow-red); }
  .summary-card[data-status="notstarted"]::before { background: var(--status-notstarted); }
  .summary-card[data-status="done"]::before { background: var(--status-done); box-shadow: var(--glow-green); }
  .summary-card[data-status="draft"]::before { background: var(--status-draft); }

  .summary-label {
    font-size: 0.68rem;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    color: var(--text-dim);
    margin-bottom: 8px;
  }

  .summary-value {
    font-size: 1.8rem;
    font-weight: 300;
    letter-spacing: -0.02em;
    line-height: 1;
  }

  .summary-card[data-status="progress"] .summary-value { color: var(--status-progress); }
  .summary-card[data-status="blocked"] .summary-value { color: var(--status-blocked); }
  .summary-card[data-status="notstarted"] .summary-value { color: var(--status-notstarted); }
  .summary-card[data-status="done"] .summary-value { color: var(--status-done); }
  .summary-card[data-status="draft"] .summary-value { color: var(--status-draft); }

  /* ── STATUS BADGE ── */
  .badge {
    display: inline-flex;
    align-items: center;
    gap: 5px;
    padding: 3px 8px;
    border-radius: 3px;
    font-size: 0.68rem;
    font-weight: 500;
    letter-spacing: 0.04em;
    text-transform: uppercase;
    white-space: nowrap;
  }

  .badge-dot {
    width: 5px;
    height: 5px;
    border-radius: 50%;
    flex-shrink: 0;
  }

  .badge-progress { background: rgba(88,166,255,0.1); color: var(--status-progress); }
  .badge-progress .badge-dot { background: var(--status-progress); box-shadow: 0 0 4px var(--status-progress); }
  .badge-blocked { background: rgba(248,81,73,0.1); color: var(--status-blocked); }
  .badge-blocked .badge-dot { background: var(--status-blocked); box-shadow: 0 0 4px var(--status-blocked); }
  .badge-notstarted { background: rgba(122,141,162,0.1); color: var(--status-notstarted); }
  .badge-notstarted .badge-dot { background: var(--status-notstarted); }
  .badge-done { background: rgba(63,185,80,0.1); color: var(--status-done); }
  .badge-done .badge-dot { background: var(--status-done); }
  .badge-draft { background: rgba(61,79,99,0.1); color: var(--status-draft); }
  .badge-draft .badge-dot { background: var(--status-draft); }

  /* Priority badges */
  .badge-p1 { background: rgba(248,81,73,0.12); color: var(--p1); border: 1px solid rgba(248,81,73,0.2); }
  .badge-p2 { background: rgba(210,153,34,0.12); color: var(--p2); border: 1px solid rgba(210,153,34,0.2); }
  .badge-p3 { background: rgba(88,166,255,0.1); color: var(--p3); border: 1px solid rgba(88,166,255,0.15); }
  .badge-p4 { background: rgba(122,141,162,0.08); color: var(--p4); border: 1px solid rgba(122,141,162,0.12); }
  .badge-p5 { background: rgba(61,79,99,0.08); color: var(--p5); border: 1px solid rgba(61,79,99,0.15); }

  .project-tag {
    font-size: 0.65rem;
    color: var(--text-dim);
    letter-spacing: 0.04em;
  }

  /* ══════════════════════════════════
     KANBAN BOARD
  ══════════════════════════════════ */
  .kanban-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 16px;
    margin-bottom: 24px;
  }

  .kanban-column {
    min-height: 200px;
  }

  .kanban-column-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 0;
    margin-bottom: 10px;
    border-bottom: 2px solid var(--border-subtle);
  }

  .kanban-column[data-status="progress"] .kanban-column-header { border-bottom-color: var(--status-progress); }
  .kanban-column[data-status="blocked"] .kanban-column-header { border-bottom-color: var(--status-blocked); }
  .kanban-column[data-status="notstarted"] .kanban-column-header { border-bottom-color: var(--status-notstarted); }
  .kanban-column[data-status="done"] .kanban-column-header { border-bottom-color: var(--status-done); }

  .kanban-column-title {
    font-size: 0.72rem;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    color: var(--text-secondary);
    font-weight: 500;
  }

  .kanban-column-count {
    font-size: 0.72rem;
    color: var(--text-dim);
  }

  .kanban-card {
    background: var(--bg-surface);
    border: 1px solid var(--border-subtle);
    border-radius: 5px;
    padding: 14px;
    margin-bottom: 8px;
    transition: border-color 0.15s ease, transform 0.15s ease, box-shadow 0.15s ease;
    cursor: pointer;
  }

  .kanban-card:hover {
    border-color: var(--border);
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  }

  .kanban-card.expanded {
    border-color: var(--border);
    background: var(--bg-elevated);
    transform: none;
  }

  .kanban-card-title {
    font-size: 0.8rem;
    font-weight: 400;
    color: var(--text-primary);
    margin-bottom: 10px;
    line-height: 1.4;
  }

  .kanban-card-meta {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
    flex-wrap: wrap;
  }

  .kanban-card-date {
    font-size: 0.62rem;
    color: var(--text-dim);
    letter-spacing: 0.02em;
  }

  /* Expandable detail panel inside cards */
  .card-details {
    display: none;
    margin-top: 12px;
    padding-top: 12px;
    border-top: 1px solid var(--border-subtle);
    font-size: 0.72rem;
    line-height: 1.6;
    color: var(--text-secondary);
  }

  .kanban-card.expanded .card-details,
  .draft-card.expanded .card-details {
    display: block;
    animation: fadeIn 0.2s ease;
  }

  .card-details dt {
    color: var(--text-dim);
    font-size: 0.65rem;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    margin-top: 8px;
    margin-bottom: 2px;
  }

  .card-details dt:first-child {
    margin-top: 0;
  }

  .card-details dd {
    color: var(--text-secondary);
    margin-bottom: 4px;
    word-break: break-word;
  }

  .card-details ul, .row-details ul {
    list-style: none;
    padding: 0;
  }

  .card-details ul li, .row-details ul li {
    padding-left: 12px;
    position: relative;
    margin-bottom: 2px;
  }

  .card-details ul li::before, .row-details ul li::before {
    content: '\203A';
    position: absolute;
    left: 0;
    color: var(--text-dim);
  }

  /* Draft section */
  .draft-section {
    border-top: 1px solid var(--border-subtle);
    padding-top: 16px;
  }

  .draft-toggle {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 0.72rem;
    color: var(--text-dim);
    cursor: pointer;
    padding: 8px 0;
    border: none;
    background: none;
    font-family: var(--font-mono);
    letter-spacing: 0.06em;
    text-transform: uppercase;
    transition: color 0.15s ease;
  }

  .draft-toggle:hover { color: var(--text-secondary); }

  .draft-toggle-arrow {
    transition: transform 0.2s ease;
    font-size: 0.6rem;
  }

  .draft-toggle.open .draft-toggle-arrow { transform: rotate(90deg); }

  .draft-cards {
    display: none;
    grid-template-columns: repeat(4, 1fr);
    gap: 16px;
    margin-top: 12px;
  }

  .draft-cards.open { display: grid; }

  .draft-card {
    background: var(--bg-surface);
    border: 1px solid var(--border-subtle);
    border-radius: 5px;
    padding: 12px;
    opacity: 0.5;
    transition: opacity 0.15s ease;
    cursor: pointer;
  }

  .draft-card:hover { opacity: 0.75; }

  .draft-card.expanded {
    opacity: 0.85;
    background: var(--bg-elevated);
  }

  .draft-card-title {
    font-size: 0.75rem;
    color: var(--text-secondary);
    margin-bottom: 6px;
  }

  /* ══════════════════════════════════
     COMMAND CENTER
  ══════════════════════════════════ */
  .command-bar-section {
    margin-bottom: 24px;
  }

  .status-bar-chart {
    display: flex;
    height: 32px;
    border-radius: 4px;
    overflow: hidden;
    gap: 2px;
  }

  .status-bar-segment {
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.65rem;
    font-weight: 600;
    letter-spacing: 0.04em;
    color: rgba(255,255,255,0.85);
    transition: flex 0.4s ease;
    position: relative;
  }

  .status-bar-segment[data-status="progress"] { background: var(--status-progress); }
  .status-bar-segment[data-status="blocked"] { background: var(--status-blocked); }
  .status-bar-segment[data-status="notstarted"] { background: var(--status-notstarted); }
  .status-bar-segment[data-status="done"] { background: var(--status-done); }
  .status-bar-segment[data-status="draft"] { background: var(--status-draft); }

  .bar-label {
    font-size: 0.62rem;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 0.06em;
    text-align: center;
  }

  .command-layout {
    display: grid;
    grid-template-columns: 1fr 320px;
    gap: 20px;
  }

  .task-list-panel {
    background: var(--bg-surface);
    border: 1px solid var(--border-subtle);
    border-radius: 6px;
    overflow: hidden;
  }

  .task-list-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 14px 18px;
    border-bottom: 1px solid var(--border-subtle);
    background: var(--bg-elevated);
  }

  .task-list-title {
    font-size: 0.72rem;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    color: var(--text-secondary);
    font-weight: 500;
  }

  .task-list-count {
    font-size: 0.68rem;
    color: var(--text-dim);
  }

  .task-list-item {
    display: grid;
    grid-template-columns: 42px 1fr auto auto auto;
    align-items: center;
    gap: 12px;
    padding: 11px 18px;
    border-bottom: 1px solid var(--border-subtle);
    transition: background 0.1s ease;
    cursor: pointer;
  }

  .task-list-item:last-child { border-bottom: none; }
  .task-list-item:hover { background: rgba(255,255,255,0.015); }
  .task-list-item.expanded { background: var(--bg-elevated); }

  .task-list-item.is-done {
    opacity: 0.45;
  }

  .task-list-priority {
    font-size: 0.7rem;
    font-weight: 600;
    text-align: center;
  }

  .task-list-name {
    font-size: 0.8rem;
    color: var(--text-primary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .task-list-date {
    font-size: 0.62rem;
    color: var(--text-dim);
    white-space: nowrap;
  }

  /* Expanded row detail */
  .row-details {
    display: none;
    grid-column: 1 / -1;
    padding: 12px 0 4px 42px;
    font-size: 0.72rem;
    line-height: 1.6;
    color: var(--text-secondary);
  }

  .task-list-item.expanded .row-details {
    display: block;
    animation: fadeIn 0.2s ease;
  }

  .row-details dt {
    color: var(--text-dim);
    font-size: 0.65rem;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    margin-top: 8px;
    margin-bottom: 2px;
  }

  .row-details dt:first-child {
    margin-top: 0;
  }

  .row-details dd {
    color: var(--text-secondary);
    margin-bottom: 4px;
    word-break: break-word;
  }

  /* Stats panel */
  .stats-panel {
    display: flex;
    flex-direction: column;
    gap: 16px;
  }

  .stat-block {
    background: var(--bg-surface);
    border: 1px solid var(--border-subtle);
    border-radius: 6px;
    padding: 18px;
  }

  .stat-block-title {
    font-size: 0.68rem;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    color: var(--text-dim);
    margin-bottom: 14px;
  }

  .h-bar-chart {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .h-bar-row {
    display: grid;
    grid-template-columns: 24px 1fr 24px;
    align-items: center;
    gap: 10px;
  }

  .h-bar-label {
    font-size: 0.7rem;
    font-weight: 600;
    text-align: center;
  }

  .h-bar-track {
    height: 16px;
    background: var(--bg-void);
    border-radius: 2px;
    overflow: hidden;
  }

  .h-bar-fill {
    height: 100%;
    border-radius: 2px;
    transition: width 0.6s cubic-bezier(0.16, 1, 0.3, 1);
  }

  .h-bar-value {
    font-size: 0.68rem;
    color: var(--text-secondary);
    text-align: right;
  }

  .project-breakdown {
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  .project-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
  }

  .project-name {
    font-size: 0.75rem;
    color: var(--text-secondary);
    font-weight: 400;
  }

  .project-count {
    display: flex;
    align-items: center;
    gap: 6px;
  }

  .project-count-num {
    font-size: 0.82rem;
    font-weight: 500;
    color: var(--text-primary);
  }

  .project-bar-mini {
    width: 60px;
    height: 4px;
    background: var(--bg-void);
    border-radius: 2px;
    overflow: hidden;
  }

  .project-bar-mini-fill {
    height: 100%;
    background: var(--status-progress);
    border-radius: 2px;
    opacity: 0.6;
  }

  .aging-list {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .aging-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    font-size: 0.72rem;
  }

  .aging-task {
    color: var(--text-secondary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 180px;
  }

  .aging-days {
    color: var(--text-dim);
    font-weight: 500;
    white-space: nowrap;
    flex-shrink: 0;
  }

  .aging-days.warn { color: var(--p2); }
  .aging-days.critical { color: var(--p1); }

  /* ══════════════════════════════════
     FILTER BAR
  ══════════════════════════════════ */
  .filter-bar {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 12px 32px;
    background: var(--bg-void);
    border-bottom: 1px solid var(--border-subtle);
  }

  .filter-search {
    flex: 1;
    max-width: 320px;
    position: relative;
  }

  .filter-search-icon {
    position: absolute;
    left: 10px;
    top: 50%;
    transform: translateY(-50%);
    color: var(--text-dim);
    font-size: 0.72rem;
    pointer-events: none;
  }

  .filter-search input {
    width: 100%;
    background: var(--bg-surface);
    border: 1px solid var(--border-subtle);
    border-radius: 4px;
    padding: 7px 10px 7px 28px;
    font-family: var(--font-mono);
    font-size: 0.75rem;
    color: var(--text-primary);
    outline: none;
    transition: border-color 0.15s ease;
  }

  .filter-search input::placeholder {
    color: var(--text-dim);
    font-size: 0.7rem;
  }

  .filter-search input:focus {
    border-color: var(--status-progress);
    box-shadow: 0 0 0 1px rgba(88,166,255,0.15);
  }

  .filter-select {
    background: var(--bg-surface);
    border: 1px solid var(--border-subtle);
    border-radius: 4px;
    padding: 7px 10px;
    font-family: var(--font-mono);
    font-size: 0.7rem;
    color: var(--text-secondary);
    outline: none;
    cursor: pointer;
    transition: border-color 0.15s ease;
    appearance: none;
    -webkit-appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='6'%3E%3Cpath d='M0 0l5 6 5-6z' fill='%233d4f63'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 8px center;
    padding-right: 24px;
  }

  .filter-select:focus {
    border-color: var(--status-progress);
  }

  .filter-select.active {
    border-color: var(--status-progress);
    color: var(--text-primary);
  }

  .filter-bar-meta {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-left: auto;
  }

  .filter-count {
    font-size: 0.68rem;
    color: var(--text-dim);
    letter-spacing: 0.04em;
  }

  .filter-count strong {
    color: var(--text-secondary);
    font-weight: 500;
  }

  .filter-clear {
    background: none;
    border: 1px solid var(--border-subtle);
    color: var(--text-dim);
    font-family: var(--font-mono);
    font-size: 0.62rem;
    letter-spacing: 0.06em;
    text-transform: uppercase;
    padding: 4px 10px;
    border-radius: 3px;
    cursor: pointer;
    transition: color 0.15s ease, border-color 0.15s ease;
    display: none;
  }

  .filter-clear:hover {
    color: var(--text-secondary);
    border-color: var(--text-dim);
  }

  .filter-clear.visible {
    display: inline-flex;
  }

  /* ══════════════════════════════════
     TAB BAR (updated for pipeline)
  ══════════════════════════════════ */
  .tab-bar-left {
    display: flex;
    gap: 0;
    flex: 1;
  }

  .tab-bar-right {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .tab kbd {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 1.3rem; height: 1.3rem;
    font-size: 0.65rem;
    border: 1px solid var(--border);
    border-radius: 3px;
    color: var(--text-dim);
    font-family: var(--font-mono);
  }
  .tab.active kbd {
    border-color: rgba(88,166,255,0.3);
    color: var(--status-progress);
  }

  .tab-badge {
    font-size: 0.65rem;
    padding: 0.1rem 0.4rem;
    border-radius: 8px;
    font-weight: 600;
  }
  .tab-badge.pending { background: rgba(210,153,34,0.15); color: var(--status-queued); }
  .tab-badge.live { background: rgba(88,166,255,0.12); color: var(--status-progress); }

  /* SSE Indicator */
  .sse-indicator {
    display: flex;
    align-items: center;
    gap: 0.4rem;
    font-size: 0.72rem;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: var(--text-dim);
  }

  .sse-dot {
    width: 6px; height: 6px; border-radius: 50%;
    background: var(--status-done);
    animation: sse-pulse 2s ease-in-out infinite;
  }
  .sse-dot.disconnected {
    background: var(--status-blocked);
    animation: none;
  }

  @keyframes sse-pulse {
    0%, 100% { opacity: 0.5; }
    50% { opacity: 1; }
  }

  /* ══════════════════════════════════
     BUDGET BAR
  ══════════════════════════════════ */
  .budget-strip {
    display: flex;
    align-items: center;
    gap: 1rem;
    padding: 0.6rem 1rem;
    background: var(--bg-surface);
    border: 1px solid var(--border-subtle);
    border-radius: 4px;
    margin-bottom: 1.25rem;
    font-size: 0.78rem;
  }

  .budget-label {
    color: var(--text-secondary);
    white-space: nowrap;
    text-transform: uppercase;
    font-size: 0.68rem;
    letter-spacing: 0.06em;
  }

  .budget-bar-track {
    flex: 1;
    height: 8px;
    background: var(--bg-elevated);
    border-radius: 4px;
    position: relative;
  }

  .budget-bar-fill {
    height: 100%;
    border-radius: 4px;
    background: linear-gradient(90deg, var(--status-progress), var(--status-done));
    width: 0%;
    transition: width 0.6s ease;
    position: relative;
    z-index: 2;
  }

  .budget-bar-target {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    border-radius: 4px;
    border: 1.5px dashed rgba(210,153,34,0.5);
    background: rgba(210,153,34,0.04);
    width: 0%;
    z-index: 1;
  }

  .budget-bar-target-label {
    position: absolute;
    top: -14px;
    right: -2px;
    font-size: 0.58rem;
    color: var(--status-queued);
    white-space: nowrap;
    letter-spacing: 0.03em;
  }

  .budget-pct {
    color: var(--text-primary);
    font-weight: 500;
    font-size: 0.82rem;
  }

  .budget-detail {
    color: var(--text-dim);
    font-size: 0.72rem;
  }

  .budget-detail .under { color: var(--status-queued); }
  .budget-detail .over { color: var(--status-blocked); }

  /* ══════════════════════════════════
     DECISIONS PANEL
  ══════════════════════════════════ */
  .decisions-panel {
    margin-bottom: 1.25rem;
    background: var(--bg-surface);
    border: 1px solid rgba(210,153,34,0.25);
    border-radius: 4px;
    overflow: hidden;
    box-shadow: 0 0 24px rgba(210,153,34,0.06);
  }

  .decisions-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0.6rem 0.85rem;
    background: rgba(210,153,34,0.07);
    border-bottom: 1px solid rgba(210,153,34,0.15);
  }

  .decisions-title {
    font-size: 0.75rem;
    font-weight: 500;
    color: var(--status-queued);
    display: flex;
    align-items: center;
    gap: 0.4rem;
  }

  .decision-item {
    padding: 0.65rem 0.85rem;
    border-bottom: 1px solid var(--border-subtle);
    cursor: pointer;
    transition: background 0.1s;
  }
  .decision-item:last-child { border-bottom: none; }
  .decision-item:hover { background: rgba(210,153,34,0.03); }

  .decision-top {
    display: flex;
    align-items: flex-start;
    gap: 0.75rem;
  }

  .decision-number {
    font-size: 0.72rem;
    font-weight: 600;
    color: var(--status-queued);
    min-width: 1.5rem;
    padding-top: 0.1rem;
  }

  .decision-content { flex: 1; }

  .decision-desc {
    font-size: 0.78rem;
    color: var(--text-primary);
    line-height: 1.4;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    flex-wrap: wrap;
    margin-bottom: 0.3rem;
  }

  .decision-desc-text { flex-shrink: 0; }

  .decision-reason {
    display: inline-block;
    font-size: 0.62rem;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    padding: 0.1rem 0.4rem;
    border-radius: 2px;
  }

  .decision-reason.user-review {
    color: var(--status-queued);
    background: rgba(210,153,34,0.1);
    border: 1px solid rgba(210,153,34,0.2);
  }
  .decision-reason.irreversible {
    color: var(--status-blocked);
    background: rgba(248,81,73,0.08);
    border: 1px solid rgba(248,81,73,0.2);
  }
  .decision-reason.budget {
    color: var(--status-progress);
    background: rgba(88,166,255,0.08);
    border: 1px solid rgba(88,166,255,0.2);
  }

  .decision-cost {
    font-size: 0.62rem;
    color: var(--text-dim);
  }

  .link-desc {
    font-size: 0.68rem;
    color: var(--text-secondary);
  }

  .decision-links {
    margin-top: 0.35rem;
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
  }

  .decision-link {
    font-size: 0.68rem;
    color: var(--status-progress);
    text-decoration: none;
    display: inline-flex;
    align-items: center;
    gap: 0.25rem;
    padding: 0.15rem 0.4rem;
    border: 1px solid rgba(88,166,255,0.2);
    border-radius: 3px;
    transition: all 0.15s;
  }
  .decision-link:hover {
    background: rgba(88,166,255,0.08);
    border-color: rgba(88,166,255,0.4);
  }

  .start-server-btn {
    font-size: 0.68rem;
    color: var(--status-progress);
    background: transparent;
    border: 1px solid rgba(88,166,255,0.2);
    border-radius: 3px;
    padding: 0.15rem 0.4rem;
    cursor: pointer;
    font-family: var(--font-mono);
    display: inline-flex;
    align-items: center;
    gap: 0.25rem;
    transition: all 0.15s;
  }
  .start-server-btn:hover {
    background: rgba(88,166,255,0.08);
    border-color: rgba(88,166,255,0.4);
  }
  .start-server-btn.loading {
    color: var(--text-dim);
    border-color: var(--border);
    pointer-events: none;
  }
  .start-server-btn.loading::after {
    content: '';
    width: 8px; height: 8px;
    border: 1.5px solid var(--text-dim);
    border-top-color: var(--status-progress);
    border-radius: 50%;
    animation: spin 0.6s linear infinite;
    margin-left: 0.25rem;
  }
  .start-server-btn.ready {
    color: var(--status-done);
    border-color: rgba(63,185,80,0.3);
  }

  .decision-actions {
    display: flex;
    gap: 0.35rem;
    flex-shrink: 0;
    padding-top: 0.1rem;
  }

  .decision-btn {
    padding: 0.25rem 0.55rem;
    border: 1px solid;
    border-radius: 3px;
    background: transparent;
    font-family: var(--font-mono);
    font-size: 0.65rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.15s;
  }

  .decision-btn.yes {
    color: var(--status-done);
    border-color: rgba(63,185,80,0.3);
  }
  .decision-btn.yes:hover { background: rgba(63,185,80,0.12); border-color: rgba(63,185,80,0.5); }

  .decision-btn.no {
    color: var(--status-blocked);
    border-color: rgba(248,81,73,0.3);
  }
  .decision-btn.no:hover { background: rgba(248,81,73,0.12); border-color: rgba(248,81,73,0.5); }

  .decision-btn.rework {
    color: var(--status-rework);
    border-color: rgba(188,140,255,0.3);
  }
  .decision-btn.rework:hover { background: rgba(188,140,255,0.1); border-color: rgba(188,140,255,0.5); }

  /* Expandable evidence section */
  .decision-evidence {
    display: none;
    margin-top: 0.6rem;
    padding-top: 0.6rem;
    border-top: 1px solid var(--border-subtle);
    font-size: 0.72rem;
    line-height: 1.55;
  }
  .decision-item.expanded .decision-evidence { display: block; }

  .evidence-section {
    margin-bottom: 0.5rem;
  }
  .evidence-section:last-child { margin-bottom: 0; }

  .evidence-label {
    font-size: 0.65rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--text-dim);
    margin-bottom: 0.15rem;
  }

  .evidence-text {
    color: var(--text-secondary);
  }
  .evidence-text a {
    color: var(--status-progress);
    text-decoration: none;
  }
  .evidence-text a:hover { text-decoration: underline; }

  .evidence-check {
    color: var(--status-done);
  }
  .evidence-risk {
    color: var(--status-queued);
  }

  /* Rework input in decisions */
  .rework-input {
    display: none;
    margin-top: 0.5rem;
  }
  .rework-input.visible {
    display: flex;
    flex-direction: column;
    gap: 0.35rem;
  }
  .rework-input textarea {
    background: var(--bg-void);
    border: 1px solid var(--border);
    border-radius: 3px;
    color: var(--text-primary);
    font-family: var(--font-mono);
    font-size: 0.72rem;
    padding: 0.5rem;
    resize: vertical;
    min-height: 3rem;
    outline: none;
  }
  .rework-input textarea:focus { border-color: rgba(188,140,255,0.4); }
  .rework-input .send-btn {
    align-self: flex-end;
    padding: 0.3rem 0.8rem;
    background: rgba(188,140,255,0.1);
    border: 1px solid rgba(188,140,255,0.3);
    border-radius: 3px;
    color: var(--status-rework);
    font-family: var(--font-mono);
    font-size: 0.68rem;
    cursor: pointer;
  }

  /* ══════════════════════════════════
     DISPATCH KANBAN
  ══════════════════════════════════ */
  .dispatch-kanban {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 1rem;
    align-items: start;
  }

  .dispatch-column {
    background: var(--bg-primary);
    border: 1px solid var(--border-subtle);
    border-radius: 4px;
    min-height: 200px;
  }

  .column-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0.6rem 0.75rem;
    border-bottom: 1px solid var(--border-subtle);
    font-size: 0.72rem;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    color: var(--text-secondary);
  }

  .column-header .count {
    font-weight: 600;
    font-size: 0.68rem;
    padding: 0.1rem 0.35rem;
    border-radius: 3px;
    background: var(--bg-elevated);
  }

  .column-cards {
    padding: 0.5rem;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  /* Dispatch cards */
  .dispatch-card {
    background: var(--bg-surface);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 0.65rem 0.75rem;
    cursor: pointer;
    transition: all 0.15s;
    position: relative;
  }
  .dispatch-card:hover {
    border-color: rgba(88,166,255,0.3);
    transform: translateY(-1px);
    box-shadow: var(--glow-blue);
  }
  .dispatch-card.expanded {
    background: var(--bg-elevated);
    border-color: rgba(88,166,255,0.25);
  }

  .card-top {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 0.35rem;
  }

  .card-project {
    font-size: 0.65rem;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    color: var(--text-dim);
  }

  .card-priority {
    font-size: 0.6rem;
    font-weight: 600;
    padding: 0.05rem 0.3rem;
    border-radius: 2px;
    border: 1px solid;
  }
  .card-priority.p1 { color: var(--p1); border-color: rgba(248,81,73,0.3); }
  .card-priority.p2 { color: var(--p2); border-color: rgba(210,153,34,0.3); }
  .card-priority.p3 { color: var(--p3); border-color: rgba(88,166,255,0.3); }
  .card-priority.p4 { color: var(--p4); border-color: rgba(122,141,162,0.3); }
  .card-priority.p5 { color: var(--p5); border-color: rgba(61,79,99,0.3); }

  .card-title {
    font-size: 0.82rem;
    font-weight: 500;
    color: var(--text-primary);
    margin-bottom: 0.35rem;
    line-height: 1.35;
  }

  .card-meta {
    display: flex;
    align-items: center;
    gap: 0.6rem;
    font-size: 0.68rem;
    color: var(--text-dim);
  }

  /* Expanded dispatch card details */
  .dispatch-card .card-details {
    display: none;
    margin-top: 0.6rem;
    padding-top: 0.6rem;
    border-top: 1px solid var(--border-subtle);
    font-size: 0.75rem;
    line-height: 1.55;
  }
  .dispatch-card.expanded .card-details { display: block; }

  .dispatch-card .card-details dt {
    color: var(--text-dim);
    font-size: 0.68rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-top: 0.5rem;
  }
  .dispatch-card .card-details dt:first-child { margin-top: 0; }
  .dispatch-card .card-details dd {
    color: var(--text-secondary);
    margin-top: 0.15rem;
  }

  /* Stop button on kanban cards */
  .card-actions {
    display: none;
    margin-top: 0.6rem;
  }
  .dispatch-card.expanded .card-actions { display: flex; }

  .stop-btn {
    padding: 0.3rem 0.7rem;
    border: 1px solid rgba(248,81,73,0.3);
    border-radius: 3px;
    background: transparent;
    color: var(--status-blocked);
    font-family: var(--font-mono);
    font-size: 0.65rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.15s;
    text-transform: uppercase;
    letter-spacing: 0.04em;
  }
  .stop-btn:hover {
    background: rgba(248,81,73,0.1);
    border-color: rgba(248,81,73,0.5);
    box-shadow: var(--glow-red);
  }

  /* Result badge */
  .result-badge {
    display: inline-flex;
    align-items: center;
    gap: 0.3rem;
    font-size: 0.65rem;
    padding: 0.15rem 0.4rem;
    border-radius: 3px;
    font-weight: 500;
  }
  .result-badge.success {
    background: rgba(63,185,80,0.1);
    color: var(--status-done);
    border: 1px solid rgba(63,185,80,0.2);
  }
  .result-badge.pr-ready {
    background: rgba(88,166,255,0.1);
    color: var(--status-progress);
    border: 1px solid rgba(88,166,255,0.2);
  }

  /* ══════════════════════════════════
     PRIORITY ALIGNMENT TABLE
  ══════════════════════════════════ */
  .handler-panel {
    margin-top: 1.25rem;
    background: var(--bg-surface);
    border: 1px solid var(--border-subtle);
    border-radius: 4px;
    padding: 0.85rem 1rem;
  }

  .handler-panel-title {
    font-size: 0.72rem;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: var(--text-dim);
    margin-bottom: 0.6rem;
  }

  .priority-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.75rem;
  }
  .priority-table th {
    text-align: left;
    color: var(--text-dim);
    font-weight: 400;
    font-size: 0.68rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    padding: 0.3rem 0.5rem;
    border-bottom: 1px solid var(--border-subtle);
  }
  .priority-table td {
    padding: 0.35rem 0.5rem;
    color: var(--text-secondary);
    border-bottom: 1px solid rgba(26,35,50,0.5);
  }
  .priority-table td:first-child {
    font-weight: 500;
    color: var(--text-primary);
  }
  .priority-table .project-priority {
    font-weight: 600;
    font-size: 0.68rem;
  }

  /* ══════════════════════════════════
     WORKERS VIEW
  ══════════════════════════════════ */
  .workers-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 1rem;
    align-items: start;
  }

  .worker-card {
    background: var(--bg-surface);
    border: 1px solid var(--border);
    border-radius: 4px;
    overflow: hidden;
  }

  .worker-header {
    padding: 0.65rem 0.85rem;
    cursor: pointer;
    transition: background 0.1s;
  }
  .worker-header:hover { background: rgba(88,166,255,0.03); }

  .worker-header-top {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 0.3rem;
  }

  .worker-id {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .worker-status-dot {
    width: 7px; height: 7px; border-radius: 50%;
    background: var(--status-progress);
    animation: worker-pulse 1.5s ease-in-out infinite;
  }

  @keyframes worker-pulse {
    0%, 100% { opacity: 0.5; box-shadow: none; }
    50% { opacity: 1; box-shadow: 0 0 6px rgba(88,166,255,0.5); }
  }

  .worker-name {
    font-size: 0.78rem;
    font-weight: 500;
    color: var(--text-primary);
  }

  .worker-project {
    font-size: 0.68rem;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  .worker-stats {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    font-size: 0.68rem;
    color: var(--text-secondary);
  }

  .worker-elapsed {
    color: var(--status-progress);
    font-weight: 500;
  }

  .worker-tokens {
    color: var(--text-dim);
  }

  .worker-model {
    color: var(--status-rework);
    font-size: 0.62rem;
    padding: 0.1rem 0.35rem;
    border: 1px solid rgba(188,140,255,0.2);
    border-radius: 2px;
    letter-spacing: 0.03em;
  }

  .worker-goal {
    font-size: 0.72rem;
    color: var(--text-secondary);
    margin-bottom: 0.4rem;
    line-height: 1.35;
  }

  /* Acceptance criteria in worker */
  .worker-criteria {
    display: flex;
    flex-direction: column;
    gap: 0.2rem;
  }

  .criteria-item {
    display: flex;
    align-items: center;
    gap: 0.4rem;
    font-size: 0.68rem;
    color: var(--text-dim);
  }

  .criteria-check {
    width: 12px; height: 12px;
    border: 1.5px solid var(--border);
    border-radius: 2px;
    flex-shrink: 0;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .criteria-check.done {
    border-color: var(--status-done);
    background: rgba(63,185,80,0.1);
  }
  .criteria-check.done::after {
    content: '\2713';
    font-size: 0.55rem;
    color: var(--status-done);
  }
  .criteria-item.met { color: var(--text-secondary); }

  /* Collapsible output — toggled by clicking header */
  .worker-output {
    display: none;
    background: var(--bg-void);
    border-top: 1px solid var(--border-subtle);
    padding: 0.6rem 0.85rem;
    font-size: 0.72rem;
    line-height: 1.6;
    max-height: 220px;
    overflow-y: auto;
    color: var(--text-secondary);
  }
  .worker-card.log-open .worker-output { display: block; }

  .worker-output .line { white-space: pre-wrap; word-break: break-all; }
  .worker-output .line.tool { color: var(--status-progress); }
  .worker-output .line.result { color: var(--text-dim); }
  .worker-output .line.success { color: var(--status-done); }
  .worker-output .line.error { color: var(--status-blocked); }
  .worker-output .line.timestamp { color: var(--text-dim); font-size: 0.65rem; }

  /* Idle worker */
  .worker-card.idle { opacity: 0.5; border-style: dashed; }
  .worker-card.idle .worker-status-dot { background: var(--text-dim); animation: none; }

  .filter-shortcut-hint {
    font-size: 0.6rem;
    color: var(--text-dim);
    letter-spacing: 0.04em;
    opacity: 0.6;
  }

  .filter-shortcut-hint kbd {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    min-width: 16px;
    height: 16px;
    padding: 0 4px;
    border: 1px solid var(--border);
    border-radius: 3px;
    font-family: var(--font-mono);
    font-size: 0.58rem;
    font-weight: 600;
  }

  /* No results state */
  .no-results {
    padding: 48px 32px;
    text-align: center;
    color: var(--text-dim);
  }

  .no-results-icon {
    font-size: 1.5rem;
    margin-bottom: 12px;
    opacity: 0.4;
  }

  .no-results-text {
    font-size: 0.78rem;
    letter-spacing: 0.04em;
    margin-bottom: 4px;
  }

  .no-results-sub {
    font-size: 0.68rem;
    letter-spacing: 0.02em;
  }
</style>
</head>
<body>

<header class="header">
  <div class="header-left">
    <div class="logo-mark"></div>
    <h1 class="header-title">dev-org <span>// backlog</span></h1>
  </div>
  <div class="header-meta">
    <span id="header-meta-text"></span>
    <span id="data-source-badge"></span>
    <div class="sse-indicator" id="sse-indicator" style="display:none;">
      <div class="sse-dot" id="sse-dot"></div>
      <span id="sse-label">live</span>
    </div>
    <button class="refresh-btn" id="refresh-btn" onclick="refreshData()" title="Reload backlog data (R)">Refresh</button>
  </div>
</header>

<nav class="tab-bar">
  <div class="tab-bar-left">
    <button class="tab active" data-view="kanban" onclick="switchView('kanban')">
      <span class="tab-label"><kbd>B</kbd> Backlog</span>
    </button>
    <button class="tab" data-view="pipeline" onclick="switchView('pipeline')">
      <span class="tab-label"><kbd>P</kbd> Pipeline <span class="tab-badge pending" id="pipeline-badge" style="display:none;">0</span></span>
    </button>
    <button class="tab" data-view="workers" onclick="switchView('workers')">
      <span class="tab-label"><kbd>W</kbd> Workers <span class="tab-badge live" id="workers-badge" style="display:none;">0</span></span>
    </button>
  </div>
  <div class="tab-bar-right">
    <select class="filter-select" id="pipeline-filter-project" aria-label="Filter by project">
      <option value="">All projects</option>
    </select>
    <select class="filter-select" id="pipeline-filter-priority" aria-label="Filter by priority">
      <option value="">All priorities</option>
      <option value="p1">P1</option>
      <option value="p2">P2</option>
      <option value="p3">P3</option>
      <option value="p4">P4</option>
      <option value="p5">P5</option>
    </select>
  </div>
</nav>

<div class="filter-bar" id="filter-bar">
  <div class="filter-search">
    <span class="filter-search-icon">&#x2315;</span>
    <input type="text" id="filter-text" placeholder="Search tasks..." aria-label="Search tasks" autocomplete="off">
  </div>
  <select class="filter-select" id="filter-status" aria-label="Filter by status">
    <option value="">All statuses</option>
    <option value="progress">In Progress</option>
    <option value="blocked">Blocked</option>
    <option value="notstarted">Not Started</option>
    <option value="done">Done</option>
    <option value="draft">Draft</option>
  </select>
  <select class="filter-select" id="filter-priority" aria-label="Filter by priority">
    <option value="">All priorities</option>
    <option value="1">P1 — Critical</option>
    <option value="2">P2 — High</option>
    <option value="3">P3 — Medium</option>
    <option value="4">P4 — Low</option>
    <option value="5">P5 — Minimal</option>
  </select>
  <select class="filter-select" id="filter-project" aria-label="Filter by project">
    <option value="">All projects</option>
  </select>
  <div class="filter-bar-meta">
    <span class="filter-count" id="filter-count"></span>
    <button class="filter-clear" id="filter-clear" onclick="clearFilters()">Clear</button>
    <span class="filter-shortcut-hint"><kbd>/</kbd> search</span>
  </div>
</div>

<div id="error-container" aria-live="polite"></div>
<main>
<div class="view active" id="view-kanban">
  <div class="loading-overlay" id="loading-indicator">
    <div class="loading-spinner"></div>
    <div class="loading-text">Loading backlog data...</div>
  </div>
</div>
<div class="view" id="view-command"></div>

<!-- ═══ PIPELINE VIEW ═══ -->
<div class="view" id="view-pipeline">
  <!-- Budget bar -->
  <div class="budget-strip">
    <span class="budget-label">Weekly budget</span>
    <div class="budget-bar-track">
      <div class="budget-bar-target"><span class="budget-bar-target-label"></span></div>
      <div class="budget-bar-fill"></div>
    </div>
    <span class="budget-pct"></span>
    <span class="budget-detail"></span>
  </div>

  <!-- Decisions panel -->
  <div class="decisions-panel">
    <div class="decisions-header">
      <div class="decisions-title">
        <svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor"><path d="M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm9 3a1 1 0 11-2 0 1 1 0 012 0zm-.25-6.25a.75.75 0 00-1.5 0v3.5a.75.75 0 001.5 0v-3.5z"/></svg>
        <span id="decisions-count-label">0 decisions awaiting approval</span>
      </div>
    </div>
    <div id="decisions-list"><!-- JS fills --></div>
  </div>

  <!-- Dispatch kanban -->
  <div class="dispatch-kanban">
    <div class="dispatch-column" data-status="queued">
      <div class="column-header"><span>Queued</span><span class="count">0</span></div>
      <div class="column-cards"></div>
    </div>
    <div class="dispatch-column" data-status="active">
      <div class="column-header"><span>Active</span><span class="count">0</span></div>
      <div class="column-cards"></div>
    </div>
    <div class="dispatch-column" data-status="blocked">
      <div class="column-header"><span>Blocked</span><span class="count">0</span></div>
      <div class="column-cards"></div>
    </div>
    <div class="dispatch-column" data-status="completed">
      <div class="column-header"><span>Completed</span><span class="count">0</span></div>
      <div class="column-cards"></div>
    </div>
  </div>

  <!-- Priority alignment -->
  <div class="handler-panel">
    <div class="handler-panel-title">Priority alignment</div>
    <table class="priority-table">
      <thead><tr><th>Project</th><th>Priority</th><th>Active</th><th>Queued</th><th>Status</th></tr></thead>
      <tbody id="priority-body"></tbody>
    </table>
  </div>
</div>

<!-- ═══ WORKERS VIEW ═══ -->
<div class="view" id="view-workers">
  <div class="workers-grid" id="workers-grid"><!-- JS fills --></div>
</div>

</main>

<script>
// ════════════════════════════════════════════
//  DATA LOADING
// ════════════════════════════════════════════
const TASKS_API = '/api/tasks';
const TASKS_DIR = 'backlog/tasks/';
let tasks = [];
let dataSource = 'none'; // 'live' | 'embedded' | 'none'

// Embedded fallback — pre-parsed task objects for offline/non-server use
const FALLBACK_TASKS = [
  {
    "title": "Audit current Claude Code workflow and skills",
    "project": "dev-org",
    "status": "notstarted",
    "priority": 2,
    "plannedCompletion": null,
    "actualCompletion": null,
    "blockers": null,
    "notes": "Evaluate which Claude Code workflows and skills (Superpowers, GSD, REPL Loop, auto-compaction, testing processes) are actively being used, which provide real value, and which are unused. This is the discovery/evaluation step that feeds into \"Flesh out workflows.md\" and \"Create skills for workflow elements.\" Originally captured as an unchecked item in brainstorming.md.",
    "spec": null,
    "added": "2026-01-28",
    "updated": "2026-01-28",
    "nextSteps": [
      "Inventory all Claude Code skills and workflows currently available",
      "Assess which are actively used vs. dormant",
      "Evaluate value provided by each active workflow",
      "Feed findings into workflows.md documentation and skill creation tasks"
    ]
  },
  {
    "title": "Audit reference layer for pre-distinction content misplacement",
    "project": "dev-org",
    "status": "notstarted",
    "priority": 2,
    "plannedCompletion": null,
    "actualCompletion": null,
    "blockers": null,
    "notes": "Early reference layer content was written before establishing clear definitions — memories should be personal to Eli (decisions, commitments, key facts about his life/work), while lessons should be learnings from experience (not public factoids anyone could look up). Preferences should capture how Eli likes to work, not restate general best practices. Content created before these boundaries were defined likely has misplaced entries: public knowledge sitting in memories, generic best practices in preferences, factoids in lessons. Needs a retroactive audit to reclassify or remove misplaced content. Related to \"Gracefully handle overlap between memories, learnings, preferences\" which defines the forward-looking strategy — this task applies that strategy retroactively.",
    "spec": null,
    "added": "2026-01-28",
    "updated": "2026-01-28",
    "nextSteps": [
      "Read all entries in memories.md, lessons.md, and preferences.md",
      "Flag entries that are public factoids rather than personal memories",
      "Flag lessons that are generic knowledge rather than experience-derived learnings",
      "Flag preferences that restate general best practices rather than Eli-specific preferences",
      "Reclassify, merge, or remove flagged entries (with Eli's approval)"
    ]
  },
  {
    "title": "Automated model switcher with visibility",
    "project": "dev-org",
    "status": "notstarted",
    "priority": 2,
    "plannedCompletion": null,
    "actualCompletion": null,
    "blockers": null,
    "notes": "More intelligently select the right Anthropic model (Opus, Sonnet, Haiku) for given scenarios instead of defaulting to one model for everything. Pair with better visibility into which model is actively being used for any given task. Could involve: rules-based routing (e.g., Haiku for simple searches, Opus for architecture decisions), cost/quality tradeoff awareness, and a visible indicator in the UI or output showing the active model. Related to context window optimization — lighter models preserve budget for complex work.",
    "spec": null,
    "added": "2026-01-28",
    "updated": "2026-01-28",
    "nextSteps": [
      "Audit current model usage patterns — when is Opus overkill vs. necessary?",
      "Research Claude Code model selection APIs and configuration options",
      "Define routing rules (task type → model mapping)",
      "Design visibility mechanism (status line, output prefix, etc.)",
      "Implement and test automated switching logic"
    ]
  },
  {
    "title": "Backlog health alerts",
    "project": "dev-org",
    "status": "notstarted",
    "priority": 4,
    "plannedCompletion": null,
    "actualCompletion": null,
    "blockers": null,
    "notes": "Proactive notifications when backlog needs attention: queue drops below threshold, high-priority tasks aging without progress, no new tasks added in X days, blocked items not being addressed.",
    "spec": null,
    "added": "2026-01-27",
    "updated": "2026-01-27",
    "nextSteps": [
      "Define alert triggers and thresholds",
      "Decide notification channel (part of mobile interface?)",
      "Implement monitoring logic"
    ]
  },
  {
    "title": "Backlog triage/prioritization skill",
    "project": "dev-org",
    "status": "notstarted",
    "priority": 5,
    "plannedCompletion": null,
    "actualCompletion": null,
    "blockers": null,
    "notes": "Create a `/claude-code-skills:triage` skill for full backlog prioritization passes. Would audit for missing items, resolve priority conflicts, re-rank, and present changes for approval. Currently done manually — codify if it becomes a recurring need.",
    "spec": null,
    "added": "2026-01-28",
    "updated": "2026-01-28",
    "nextSteps": [
      "Validate manual triage process through repeated use",
      "Identify repeatable patterns worth codifying",
      "Design skill structure and implement"
    ]
  },
  {
    "title": "Backlog visualization dashboard",
    "project": "dev-org",
    "status": "done",
    "priority": 1,
    "plannedCompletion": null,
    "actualCompletion": "2026-01-28",
    "blockers": null,
    "notes": "Web-based dashboard to visualize the dev-org backlog. Phase 1: self-contained HTML file (`dashboard.html`) with embedded backlog data, regex parser, two views (Kanban Board + Command Center), expandable card/row details, keyboard shortcuts (B/C), draft section toggle, dark mission-control aesthetic. Phase 2: live file loading via `fetch()` with embedded fallback, loading spinner, Live/Snapshot data source badge, Refresh button (R shortcut), error banner, parser hardened against backlog preamble, minimal Node.js dev server (`serve.js`). Phase 3: filtering and search — text search across title/notes/project/blockers, status and priority dropdown filters, filter count badge, Clear button, `/` keyboard shortcut to focus search, Escape to clear, empty state. Filters apply to both views simultaneously. Future: VS Code WebView integration, auto-refresh/file watching.",
    "spec": null,
    "added": "2026-01-28",
    "updated": "2026-01-28",
    "nextSteps": [
      "Design brainstorming with interactive mockups (3 layout options)",
      "Design review: selected Kanban Board + Command Center, dropped Priority Matrix",
      "Built backlog.md regex parser extracting all task fields",
      "Built Kanban Board view with 4 columns, summary cards, collapsible draft section",
      "Built Command Center view with status bar, priority-sorted task list, stats panel (priority distribution, projects, aging)",
      "Added expandable inline details (notes, blockers, next steps, dates) on click",
      "Added keyboard shortcuts (B/C for tab switching)",
      "Code review + accessibility fixes (ARIA attributes, keyboard navigation, reduced-motion, semantic HTML)",
      "Phase 2: Live file loading via fetch() with embedded fallback, loading state, data source badge, refresh button, parser preamble-stripping",
      "Created serve.js dev server for local HTTP serving",
      "Phase 2 code review + fixes (concurrent refresh guard, URI error handling, aria-live)",
      "Phase 3: Filter bar with text search, status dropdown, priority dropdown",
      "Filter state management with simultaneous apply to both Kanban and Command Center views",
      "Keyboard shortcuts: `/` to focus search, Escape to clear filters",
      "Filter count badge, Clear button, empty state for zero results"
    ]
  },
  {
    "title": "Codify personal \"why\"",
    "project": "dev-org",
    "status": "done",
    "priority": 2,
    "plannedCompletion": null,
    "actualCompletion": "2026-01-28",
    "blockers": null,
    "notes": "why.md now contains \"The Deeper Why\" section with core life goal (SaaS product → own tech company), full career arc showing pattern of building/entrepreneurship, values from \"34 traits\" document, two-sides self-awareness from wedding vows, competition as identity, and dev-org's role as infrastructure for the entrepreneurial goal. Enriched through deep research of Google Drive, LinkedIn, social media, and local projects.",
    "spec": null,
    "added": "2026-01-28",
    "updated": "2026-01-28",
    "nextSteps": [
      "Ran 4 parallel research sessions (Drive, LinkedIn, Social, Projects) to mine data about Eli",
      "Merged findings into why.md with \"The Deeper Why\" section",
      "Added career arc, values, vulnerability, competition identity, dev-org's role"
    ]
  },
  {
    "title": "Collect and scope project ideas from offline notes",
    "project": "dev-org",
    "status": "notstarted",
    "priority": 1,
    "plannedCompletion": null,
    "actualCompletion": null,
    "blockers": null,
    "notes": "Eli has offline notes (physical, mental, scattered docs) about project ideas including eval-platform, multi-agent-startup, and potentially others. These need to be collected into a single place with enough context for Claude to scope each one — what the idea is, target market, competitive landscape, technical feasibility, and rough effort estimate. This feeds into the project prioritization system.",
    "spec": null,
    "added": "2026-01-28",
    "updated": "2026-01-28",
    "nextSteps": [
      "Session with Eli to dump all project ideas and offline notes",
      "For each idea: capture name, description, target user, problem it solves",
      "Claude scopes each: competitive landscape, technical feasibility, effort estimate",
      "Add scoped ideas as draft backlog items or update existing parking lot repos",
      "Re-evaluate project priority ranking with new information"
    ]
  },
  {
    "title": "Context window optimization (\"Thin Orchestrator\" pattern)",
    "project": "dev-org",
    "status": "notstarted",
    "priority": 2,
    "plannedCompletion": null,
    "actualCompletion": null,
    "blockers": null,
    "notes": "Keep main CC session focused on delegation, not implementation. Target <50% context utilization. Spawn sub-agents for implementation/verification. Add context budget monitoring and smart delegation patterns. Applies to all CC usage.",
    "spec": "[context-window-optimization.md](specs/context-window-optimization.md)",
    "added": "2026-01-28",
    "updated": "2026-01-28",
    "nextSteps": [
      "Copy TC spec to dev-org specs folder",
      "Adapt patterns for dev-org's simpler architecture",
      "Document delegation best practices"
    ]
  },
  {
    "title": "Conversational deep-dive on personal \"why\"",
    "project": "dev-org",
    "status": "notstarted",
    "priority": 3,
    "plannedCompletion": null,
    "actualCompletion": null,
    "blockers": null,
    "notes": "The research-based enrichment of why.md is complete (career arc, values, vulnerability, competition, dev-org's role), but the conversational piece — things only Eli can articulate — was never finished. The original brainstorming session identified the need to codify what keeps him disciplined, and the first deep-dive surfaced the two-layer structure (immediate: cognitive overload relief; ultimate: SaaS → own tech company). Still unexplored: what kind of SaaS / what domain, what skills and advantages he brings (his unfair edge), what \"running a small tech company\" looks like concretely (solo? team? bootstrapped? VC?), and what keeps him disciplined day-to-day. Research findings in research/ provide rich context to inform the conversation.",
    "spec": null,
    "added": "2026-01-28",
    "updated": "2026-01-28",
    "nextSteps": [
      "Conversational session with Eli exploring SaaS direction, unfair advantages, company vision, and discipline mechanisms",
      "Update why.md with Eli's articulated answers",
      "Cross-reference with existing research findings for consistency"
    ]
  },
  {
    "title": "Create handoff skill for Claude Code sessions",
    "project": "dev-org",
    "status": "done",
    "priority": 3,
    "plannedCompletion": null,
    "actualCompletion": "2026-01-27",
    "blockers": null,
    "notes": "Fifth skill for dev-org. Packages session context into handoff documents and starter prompts for continuation by fresh Claude Code sessions. Integrates with /claude-code-skills:review to capture learnings first.",
    "spec": null,
    "added": "2026-01-27",
    "updated": "2026-01-27",
    "nextSteps": [
      "Designed skill structure (docs/plans/2026-01-27-handoff-skill-design.md)",
      "Created skills/handoff/SKILL.md with full instructions",
      "Plugin discovery is automatic via skills/*/SKILL.md pattern"
    ]
  },
  {
    "title": "Create retrospective skill",
    "project": "dev-org",
    "status": "notstarted",
    "priority": 2,
    "plannedCompletion": null,
    "actualCompletion": null,
    "blockers": null,
    "notes": "A `/claude-code-skills:retro` skill invoked when something has gone wrong with Claude's behavior during a session. Uses the transcript as raw material to create a powerful teaching moment — extracts what went wrong, why it went wrong, what the correct behavior should have been, and encodes the learning into the reference layer (lessons.md, preferences.md, or a new anti-patterns file). The goal is to turn failure into durable improvement so the same mistake never recurs across sessions.",
    "spec": null,
    "added": "2026-01-28",
    "updated": "2026-01-28",
    "nextSteps": [
      "Design the skill flow: how to identify the problematic behavior from transcript context",
      "Define output format — lesson entry, anti-pattern, preference update, or all three",
      "Decide where learnings are stored (lessons.md? new anti-patterns.md? preferences.md?)",
      "Implement skills/retro/SKILL.md",
      "Test with a real transcript where Claude's behavior was suboptimal"
    ]
  },
  {
    "title": "Create skills for workflow elements",
    "project": "dev-org",
    "status": "notstarted",
    "priority": 2,
    "plannedCompletion": null,
    "actualCompletion": null,
    "blockers": null,
    "notes": "Turn documented workflows into executable Claude Code skills. These skills codify consistent processes that should be applied across sessions. Starting with code review and feature/product testing as highest-value workflows. Depends on \"Flesh out workflows.md documentation\" being complete first.",
    "spec": null,
    "added": "2026-01-28",
    "updated": "2026-01-28",
    "nextSteps": [
      "**Code Review skill** - Create `/claude-code-skills:code-review` that invokes deep code review with consistent criteria",
      "**Feature Testing skill** - Create `/claude-code-skills:test-feature` for structured product/feature testing workflow",
      "Assess remaining workflows (REPL Loop, Auto-Compaction, GSD integration) for skill conversion",
      "Update workflows.md to link to corresponding skills"
    ]
  },
  {
    "title": "Daily scheduled repo sync",
    "project": "dev-org",
    "status": "notstarted",
    "priority": 2,
    "plannedCompletion": null,
    "actualCompletion": null,
    "blockers": null,
    "notes": "Daily automated run that reviews all project repos and updates backlog items based on actual repo state. Catches drift between what's been built and what the backlog claims. Propose-only model — generates a change report for Eli to review before any backlog modifications are applied.",
    "spec": null,
    "added": "2026-01-28",
    "updated": "2026-01-28",
    "nextSteps": [
      "Write the starter prompt that Claude Code will execute during each sync run",
      "Build the sync report template (per-repo section with findings + proposed backlog changes)",
      "Create a `logs/` directory convention for sync reports",
      "Write a Windows Task Scheduler setup script (PowerShell) to schedule the daily run",
      "Do a manual test run across all repos to validate the approach",
      "Schedule the daily run once manual test is clean"
    ]
  },
  {
    "title": "Dynamic Gemini review triggering",
    "project": "dev-org",
    "status": "notstarted",
    "priority": 4,
    "plannedCompletion": null,
    "actualCompletion": null,
    "blockers": "Depends on Gemini MCP being complete and validated",
    "notes": "Auto-trigger Gemini reviews based on: security-sensitive paths, change size thresholds, risk scoring, pattern matching. Needs data from manual reviews first to calibrate triggers.",
    "spec": null,
    "added": "2026-01-28",
    "updated": "2026-01-28",
    "nextSteps": [
      "Complete Gemini MCP and gather manual review data",
      "Analyze which reviews found valid issues",
      "Design trigger rules based on data",
      "Implement automatic triggering"
    ]
  },
  {
    "title": "Fix review skill (infer, don't interrogate)",
    "project": "dev-org",
    "status": "notstarted",
    "priority": 2,
    "plannedCompletion": null,
    "actualCompletion": null,
    "blockers": null,
    "notes": "The review skill currently asks too many open-ended questions sequentially, which creates friction in daily use. Should infer learnings from session context and propose entries, only asking targeted questions when genuinely ambiguous. See lessons.md for the original observation.",
    "spec": null,
    "added": "2026-01-28",
    "updated": "2026-01-28",
    "nextSteps": [
      "Review current review skill implementation for question flow",
      "Redesign to infer learnings from session context first",
      "Only ask targeted questions when classification is ambiguous",
      "Test revised skill in daily workflow"
    ]
  },
  {
    "title": "Flesh out workflows.md documentation",
    "project": "dev-org",
    "status": "notstarted",
    "priority": 2,
    "plannedCompletion": null,
    "actualCompletion": null,
    "blockers": null,
    "notes": "workflows.md has stubs for REPL Loop, Auto-Compaction, and Testing Processes with no real content. These should be documented with enough detail to be useful reference material for Claude sessions.",
    "spec": null,
    "added": "2026-01-28",
    "updated": "2026-01-28",
    "nextSteps": [
      "Document REPL Loop workflow with steps and when to use",
      "Document Auto-Compaction patterns and triggers",
      "Document Testing Processes workflow",
      "Review for completeness against actual daily usage"
    ]
  },
  {
    "title": "Gemini Adversarial Code Review MCP Server",
    "project": "dev-org",
    "status": "blocked",
    "priority": 3,
    "plannedCompletion": null,
    "actualCompletion": null,
    "blockers": "Waiting for Google AI API quota reset (free tier daily limit)",
    "notes": "Phase 1 complete - MCP server implemented at traffic-control/gemini-review-mcp/. Provides cross-model code review where Gemini reviews Claude's code with adversarial prompting to catch blind spots. Tiered merge blocking (critical/major/minor), 32 unit tests passing. Note: Code currently lives in traffic-control/gemini-review-mcp/. Since traffic-control is deprecated, code should be relocated when this task is unblocked.",
    "spec": "[gemini-adversarial-code-review.md](specs/gemini-adversarial-code-review.md)",
    "added": "2026-01-28",
    "updated": "2026-01-28",
    "nextSteps": [
      "Test with real API calls once quota resets",
      "Proceed to Phase 2: Adversarial prompting refinement",
      "Phase 3: TrafficControl integration (or dev-org workflow integration)",
      "Phase 4: Learning & optimization based on feedback"
    ]
  },
  {
    "title": "Get golf clip online",
    "project": "personal",
    "status": "notstarted",
    "priority": 1,
    "plannedCompletion": null,
    "actualCompletion": null,
    "blockers": null,
    "notes": "Get the golf clip published/uploaded online ASAP.",
    "spec": null,
    "added": "2026-01-28",
    "updated": "2026-01-28",
    "nextSteps": [
      "Identify the golf clip file and target platform",
      "Upload and publish"
    ]
  },
  {
    "title": "Gracefully handle overlap between memories, learnings, preferences",
    "project": "dev-org",
    "status": "notstarted",
    "priority": 2,
    "plannedCompletion": null,
    "actualCompletion": null,
    "blockers": null,
    "notes": "The reference layer files (memories.md, lessons.md, preferences.md) have natural overlap — e.g., a lesson learned could also be a preference, a memory could imply a lesson. Currently no guidance on where something belongs when it spans categories, leading to potential duplication or inconsistent placement. Need a strategy: could be deduplication rules, cross-references between files, a single unified file, or clear decision criteria for categorization. Should also address what happens when the review skill captures something that fits multiple categories.",
    "spec": null,
    "added": "2026-01-28",
    "updated": "2026-01-28",
    "nextSteps": [
      "Audit current content across memories.md, lessons.md, and preferences.md for existing overlap",
      "Define clear boundaries and decision criteria for each file's purpose",
      "Design cross-reference or deduplication strategy",
      "Update the review skill to apply the new categorization rules",
      "Document the strategy in CLAUDE.md or a ways-of-working file"
    ]
  },
  {
    "title": "Handoff skill: Support cross-directory file references",
    "project": "dev-org",
    "status": "notstarted",
    "priority": 3,
    "plannedCompletion": null,
    "actualCompletion": null,
    "blockers": null,
    "notes": "Enhance /claude-code-skills:handoff skill to support referencing files from other directories/projects in starter prompts. Currently handoff documents assume context within the same directory. Cross-directory references would enable handoffs that span multiple repos or include relevant files from related projects.",
    "spec": null,
    "added": "2026-01-28",
    "updated": "2026-01-28",
    "nextSteps": [
      "Review current handoff skill implementation for file reference handling",
      "Design syntax for cross-directory references (absolute paths? project aliases?)",
      "Implement path resolution and validation",
      "Update starter prompt generation to include referenced files"
    ]
  },
  {
    "title": "Historical tracking and metrics",
    "project": "dev-org",
    "status": "notstarted",
    "priority": 4,
    "plannedCompletion": null,
    "actualCompletion": null,
    "blockers": null,
    "notes": "Track progress over time - tasks added vs completed per day/week, average time in queue, throughput by project. Will need to decide on storage approach (append-only log file? separate metrics file?).",
    "spec": null,
    "added": "2026-01-27",
    "updated": "2026-01-27",
    "nextSteps": [
      "Design data model for historical tracking",
      "Decide storage approach that fits markdown-based system",
      "Implement basic metrics collection"
    ]
  },
  {
    "title": "Hook: Auto-handoff at context window threshold",
    "project": "dev-org",
    "status": "done",
    "priority": 1,
    "plannedCompletion": null,
    "actualCompletion": "2026-01-28",
    "blockers": null,
    "notes": "Claude Code hook that monitors context window usage after every Claude turn. When estimated usage crosses 60%, automatically triggers `/claude-code-skills:handoff` to package the session for continuation. Uses Node.js script (`hooks/context-monitor.js`) with streaming JSONL transcript parsing, chars/4 token estimation heuristic, single-fire marker mechanism, and JSONL usage logging. Installed as Stop + PreCompact hooks in `~/.claude/settings.json`. 49 tests passing. Design doc: `docs/plans/2026-01-28-auto-handoff-hook-design.md`.",
    "spec": null,
    "added": "2026-01-27",
    "updated": "2026-01-28",
    "nextSteps": [
      "Researched Claude Code hook events and capabilities (12 events, no built-in context % exposed)",
      "Designed token estimation via transcript JSONL streaming with chars/4 heuristic",
      "Built `hooks/context-monitor.js` — Stop hook triggers handoff at 60%, PreCompact hook logs compaction",
      "Built `hooks/context-monitor.cmd` — polyglot wrapper (Windows + Unix), always exits 0",
      "Created `hooks/config-reference.json` — documentation of settings.json hooks block",
      "Installed hooks config into `~/.claude/settings.json`",
      "Built test harness (49 tests): threshold, single-fire, PreCompact, schema, edge cases (missing files, malformed JSONL, empty stdin, boundary conditions)",
      "Code reviewed: fixed streaming (readline vs full-file read), fd-based log writes, hookType validation, .cmd always-exit-0, discounted file-size fallback"
    ]
  },
  {
    "title": "Hook: Auto-orient at session start",
    "project": "dev-org",
    "status": "notstarted",
    "priority": 3,
    "plannedCompletion": null,
    "actualCompletion": null,
    "blockers": null,
    "notes": "Use Claude Code hooks to automatically invoke /claude-code-skills:orient when a new session starts. Natural companion to the existing \"auto-review at session end\" hook idea. Would ensure every session begins with context awareness and prioritization. Originally described in phase-4-handoff.md Phase 6 capabilities.",
    "spec": null,
    "added": "2026-01-28",
    "updated": "2026-01-28",
    "nextSteps": [
      "Research Claude Code hook system for session-start events",
      "Determine if session-start hook exists or alternative trigger needed",
      "Implement and test hook configuration"
    ]
  },
  {
    "title": "Hook: Auto-run /claude-code-skills:review at session end",
    "project": "dev-org",
    "status": "draft",
    "priority": 2,
    "plannedCompletion": null,
    "actualCompletion": null,
    "blockers": null,
    "notes": "Use Claude Code hooks to automatically invoke /claude-code-skills:review when a session ends. Ensures learnings, memories, and lessons are captured without relying on manual invocation. Need to research hook configuration and session-end event availability.",
    "spec": null,
    "added": "2026-01-27",
    "updated": "2026-01-27",
    "nextSteps": [
      "Research Claude Code hook system and available events",
      "Determine if session-end hook exists or if alternative trigger needed",
      "Implement and test hook configuration"
    ]
  },
  {
    "title": "Implement remaining dev-org skills (orient, review)",
    "project": "dev-org",
    "status": "done",
    "priority": 1,
    "plannedCompletion": null,
    "actualCompletion": "2026-01-27",
    "blockers": null,
    "notes": "Phase 3 complete - all four skills implemented with calendar integration",
    "spec": null,
    "added": "2026-01-27",
    "updated": "2026-01-27",
    "nextSteps": [
      "Built /claude-code-skills:orient skill with calendar integration",
      "Built /claude-code-skills:review skill for updating reference layer",
      "Code reviewed both skills"
    ]
  },
  {
    "title": "Migrate Traffic Control features to dev-org backlog",
    "project": "dev-org",
    "status": "done",
    "priority": 2,
    "plannedCompletion": null,
    "actualCompletion": "2026-01-28",
    "blockers": null,
    "notes": "Triaged features from deprecated traffic-control project. dev-org is TC v2 with simpler markdown-based architecture. Many TC features (search, bulk ops, dependency visualization) unnecessary since Claude handles them naturally.",
    "spec": null,
    "added": "2026-01-28",
    "updated": "2026-01-28",
    "nextSteps": [
      "Updated backlog format (added Project field, numeric priorities 1-5, Spec field)",
      "Created backlog/specs/ directory structure",
      "Migrated items: Mobile interface (P1), Backlog health alerts (P3), Historical tracking (P3), Weekly digest (P4), Context window optimization (P2), Gemini Adversarial Code Review (P2), Offline Claude Code (P3), Multi-model experiments (P4), Dynamic Gemini triggering (P4)",
      "Copied specs for context-window-optimization, gemini-adversarial-code-review, offline-claude-code",
      "Skipped: Task filtering, bulk ops, dependency visualization (Claude handles naturally)"
    ]
  },
  {
    "title": "Mobile interface for dev-org",
    "project": "dev-org",
    "status": "done",
    "priority": 1,
    "plannedCompletion": null,
    "actualCompletion": "2026-01-28",
    "blockers": null,
    "notes": "Mobile access to dev-org via Happy (https://happy.engineering/) — open-source Claude Code mobile client with E2E encryption. Happy CLI v0.13.0 installed globally, mobile app paired and tested. Skills work from phone. No custom quick-action layer needed — Happy provides full Claude Code access natively.",
    "spec": null,
    "added": "2026-01-27",
    "updated": "2026-01-28",
    "nextSteps": [
      "Installed Happy CLI v0.13.0 (`npm i -g happy-coder`)",
      "Paired mobile app with desktop via QR code",
      "Tested dev-org skills from mobile — confirmed working",
      "Evaluated quick-action layer — not needed, Happy provides full access"
    ]
  },
  {
    "title": "Multi-model collaboration experiments",
    "project": "dev-org",
    "status": "notstarted",
    "priority": 4,
    "plannedCompletion": null,
    "actualCompletion": null,
    "blockers": "Depends on Gemini MCP being complete",
    "notes": "Long-term research on optimal multi-model collaboration patterns. Tests approaches like adversarial review, spec-build-verify, parallel implementation, iterative refinement, ensemble voting. Requires experimental framework and A/B testing infrastructure.",
    "spec": null,
    "added": "2026-01-28",
    "updated": "2026-01-28",
    "nextSteps": [
      "Complete Gemini MCP as baseline",
      "Build experiment tracking system",
      "Collect baseline metrics on single-model Claude",
      "Test multi-model approaches systematically"
    ]
  },
  {
    "title": "Offline Claude Code (Local AI Stack)",
    "project": "dev-org",
    "status": "draft",
    "priority": 4,
    "plannedCompletion": null,
    "actualCompletion": null,
    "blockers": null,
    "notes": "Build offline Claude Code alternative on local hardware. Comprehensive research complete - open models now achieve 90-95% of Claude Sonnet quality. Primary model: Qwen3-Coder-30B. Hardware options from $3.5K (RTX 5090) to $15K (dual 5090). Provides unlimited usage, data privacy, offline capability.",
    "spec": "[offline-claude-code.md](specs/offline-claude-code.md)",
    "added": "2026-01-28",
    "updated": "2026-01-28",
    "nextSteps": [
      "Decide on hardware budget and purchase",
      "Phase 1: Foundation - basic local inference with OpenCode",
      "Phase 2: Production inference optimization",
      "Phase 3: RAG for codebase awareness",
      "Phase 4: MCP integration"
    ]
  },
  {
    "title": "Phase 4: Daily use of dev-org system",
    "project": "dev-org",
    "status": "progress",
    "priority": 1,
    "plannedCompletion": "2026-02-10",
    "actualCompletion": null,
    "blockers": null,
    "notes": "Validate the manual workflow before adding automation. Use the system daily for 1-2 weeks. Session 3 (2026-01-28): Installed Happy CLI for mobile access, researched current state of Happy ecosystem including Anthropic's Jan 2026 policy impact. Mobile pairing ready for manual testing.",
    "spec": null,
    "added": "2026-01-27",
    "updated": "2026-01-28",
    "nextSteps": [
      "Test all four skills in daily workflow",
      "Complete Happy mobile pairing and test skills from phone",
      "Document friction points and learnings using /claude-code-skills:review",
      "Capture at least 3 entries in memories.md or lessons.md from using the system"
    ]
  },
  {
    "title": "Populate reference layer through deep research",
    "project": "dev-org",
    "status": "done",
    "priority": 1,
    "plannedCompletion": null,
    "actualCompletion": "2026-01-28",
    "blockers": null,
    "notes": "Deep research to build comprehensive profile of Eli for the reference layer. Ran 4 parallel research sessions (Google Drive, LinkedIn/professional web, social media, local projects) writing findings to research/ directory (1,255 lines total). Merged all findings into 7 existing reference files and created 2 new ones (bio.md, skills.md). Reference layer now contains: full biographical facts, career timeline, education, family, interests, technical skills inventory, development patterns, tools/stack, and personal style/tendencies.",
    "spec": null,
    "added": "2026-01-28",
    "updated": "2026-01-28",
    "nextSteps": [
      "Session 1: Google Drive deep dive (441 lines — career, education, family, interests, values)",
      "Session 2: LinkedIn & professional web (273 lines — Microsoft career, CMC thesis, volunteer work)",
      "Session 3: Social media (257 lines — low public footprint, GitHub profile, quiet builder persona)",
      "Session 4: Local projects analysis (284 lines — 8 projects, tech stack, building patterns)",
      "Eli-verified corrections (wedding July 2022, Ira born July 26 2025, FannoTek employee not co-founder)",
      "Merged into: why.md, constraints.md, preferences.md, memories.md, tools.md, workflows.md",
      "Created: bio.md (comprehensive biographical summary), skills.md (technical & professional inventory)"
    ]
  },
  {
    "title": "Prioritize coding projects",
    "project": "dev-org",
    "status": "done",
    "priority": 1,
    "plannedCompletion": null,
    "actualCompletion": "2026-01-28",
    "blockers": null,
    "notes": "Inventoried all 11 projects in c:\\Users\\Eli\\projects\\. Assessed each for state, purpose, last activity, and alignment with core SaaS goal. Final priority ranking established with Eli's input.",
    "spec": null,
    "added": "2026-01-28",
    "updated": "2026-01-28",
    "nextSteps": []
  },
  {
    "title": "Register dev-org skills as Claude Code slash commands",
    "project": "dev-org",
    "status": "done",
    "priority": 1,
    "plannedCompletion": null,
    "actualCompletion": "2026-01-28",
    "blockers": null,
    "notes": "All 5 dev-org skills (orient, add, status, review, handoff) now appear as native slash commands in Claude Code. Solution: local marketplace registration via known_marketplaces.json with \"directory\" source type, plus installed_plugins.json and settings.json entries using \"dev-org@dev-org-local\" key format. Configuration survived VS Code restart.",
    "spec": null,
    "added": "2026-01-27",
    "updated": "2026-01-28",
    "nextSteps": [
      "Created .claude-plugin/plugin.json manifest",
      "Reorganized skills into subdirectories (skills/orient/SKILL.md, etc.)",
      "Added YAML frontmatter to each skill file",
      "Created commands/ directory with 5 routing files (orient, add, status, review, handoff)",
      "Created .claude-plugin/marketplace.json (local marketplace definition)",
      "Added dev-org-local marketplace to known_marketplaces.json with \"directory\" source type",
      "Added dev-org@dev-org-local to installed_plugins.json",
      "Updated settings.json key from \"dev-org\" to \"dev-org@dev-org-local\"",
      "Verified slash commands appear after VS Code restart"
    ]
  },
  {
    "title": "Repo cleanup: archive stale files and collapse done items",
    "project": "dev-org",
    "status": "notstarted",
    "priority": 4,
    "plannedCompletion": null,
    "actualCompletion": null,
    "blockers": null,
    "notes": "Housekeeping pass on the repo. Archive 6 stale root-level files (brainstorming.md, implementation-handoff.md, starter-prompt.md, phase-4-handoff.md, handoff-prompt.md, session-handoff.md) to docs/plans/ with -archived suffix. Collapse the 5 completed backlog tasks to reduce clutter. Check if TC migration cleanup tasks (rename portfolio dir, delete backup, update refs) were ever completed.",
    "spec": null,
    "added": "2026-01-28",
    "updated": "2026-01-28",
    "nextSteps": [
      "Archive stale root-level files to docs/plans/ with -archived suffix",
      "Collapse completed backlog items (summary line + completion date only)",
      "Verify TC migration cleanup tasks status"
    ]
  },
  {
    "title": "Weekly digest",
    "project": "dev-org",
    "status": "draft",
    "priority": 4,
    "plannedCompletion": null,
    "actualCompletion": null,
    "blockers": null,
    "notes": "Weekly summary of what happened - completed tasks, currently in progress, upcoming high-priority items, tasks that aged significantly. Could be delivered via mobile interface or as a scheduled skill run.",
    "spec": null,
    "added": "2026-01-28",
    "updated": "2026-01-28",
    "nextSteps": [
      "Define digest content and format",
      "Decide delivery mechanism (mobile push? email? scheduled CC session?)",
      "Implement generation logic"
    ]
  },
  {
    "title": "Windows desktop widget for Claude usage monitoring",
    "project": "dev-org",
    "status": "notstarted",
    "priority": 3,
    "plannedCompletion": null,
    "actualCompletion": null,
    "blockers": null,
    "notes": "Desktop widget to monitor session and weekly Claude API usage. Recommended approach: Rainmeter — free, open-source, native Windows desktop integration, Lua scripting for API calls/file parsing, low resource footprint. Alternatives considered: Windows 11 widget board (too complex for the payoff), Electron tray app (heavy, not a true desktop widget). Could poll the Anthropic API usage endpoint or read from a local cache file updated by a scheduled task.",
    "spec": null,
    "added": "2026-01-28",
    "updated": "2026-01-28",
    "nextSteps": [
      "Research Anthropic API usage/billing endpoint availability and authentication",
      "Design Rainmeter skin layout (session usage, weekly usage, remaining quota)",
      "Implement Lua script to fetch and parse usage data",
      "Style the widget to match Windows desktop aesthetic"
    ]
  }
];

// ════════════════════════════════════════════
//  PARSER
// ════════════════════════════════════════════
function parseTaskFile(md) {
  // Strip fenced code blocks
  const cleanMd = md.replace(/```[\s\S]*?```/g, '');

  const title = (cleanMd.match(/^### (.+)/m) || [])[1]?.trim() || 'Untitled';
  const project = extractField(cleanMd, 'Project');
  if (!project) return null; // Not a valid task file

  return {
    title,
    project,
    status: normalizeStatus(extractField(cleanMd, 'Status')),
    priority: parseInt(extractField(cleanMd, 'Priority')) || 5,
    plannedCompletion: cleanNone(extractField(cleanMd, 'Planned completion')),
    actualCompletion: cleanNone(extractField(cleanMd, 'Actual completion')),
    blockers: cleanNone(extractField(cleanMd, 'Blockers')),
    notes: extractField(cleanMd, 'Notes'),
    spec: cleanNone(extractField(cleanMd, 'Spec')),
    added: extractField(cleanMd, 'Added'),
    updated: extractField(cleanMd, 'Updated'),
    nextSteps: extractNextSteps(cleanMd),
  };
}

function extractField(text, fieldName) {
  const regex = new RegExp('\\*\\*' + fieldName + ':\\*\\*\\s*(.+)', 'i');
  const match = text.match(regex);
  return match ? match[1].trim() : '';
}

function normalizeStatus(raw) {
  const s = raw.toLowerCase().trim();
  if (s === 'in progress') return 'progress';
  if (s === 'not started') return 'notstarted';
  if (s === 'blocked') return 'blocked';
  if (s === 'done') return 'done';
  if (s === 'draft') return 'draft';
  return 'draft';
}

function cleanNone(val) {
  if (!val || val.toLowerCase() === 'none' || val === '') return null;
  return val;
}

function extractNextSteps(text) {
  const steps = [];
  const match = text.match(/####\s+(Next steps|Completed)\s*\n([\s\S]*?)(?=\n---|\n###|$)/i);
  if (match) {
    const block = match[2];
    const lineRegex = /^\d+\.\s+(.+)/gm;
    let m;
    while ((m = lineRegex.exec(block)) !== null) {
      steps.push(m[1].trim());
    }
  }
  return steps;
}

// ════════════════════════════════════════════
//  COMPUTED DATA
// ════════════════════════════════════════════

const statusLabels = {
  progress: 'In Progress',
  blocked: 'Blocked',
  notstarted: 'Not Started',
  done: 'Done',
  draft: 'Draft',
};

const statusCommandLabels = {
  progress: 'Active',
  blocked: 'Blocked',
  notstarted: 'Queued',
  done: 'Done',
  draft: 'Draft',
};

const priorityLabels = { 1: 'P1', 2: 'P2', 3: 'P3', 4: 'P4', 5: 'P5' };

function countByStatus(status) {
  return tasks.filter(t => t.status === status).length;
}

function countByPriority(p) {
  return tasks.filter(t => t.priority === p).length;
}

function getProjects() {
  const map = {};
  tasks.forEach(t => {
    const p = t.project || 'unknown';
    map[p] = (map[p] || 0) + 1;
  });
  return Object.entries(map).sort((a, b) => b[1] - a[1]);
}

function getAgingTasks() {
  const now = new Date();
  return tasks
    .filter(t => t.status !== 'done' && t.status !== 'draft' && t.added)
    .map(t => {
      const added = parseDate(t.added);
      const days = added ? Math.floor((now - added) / (1000 * 60 * 60 * 24)) : 0;
      return { title: t.title, status: t.status, ageDays: days };
    })
    .sort((a, b) => b.ageDays - a.ageDays)
    .slice(0, 5);
}

function getDisplayDate(task) {
  if (task.status === 'done' && task.actualCompletion) {
    return formatDate(task.actualCompletion);
  }
  if (task.plannedCompletion) {
    return formatDate(task.plannedCompletion);
  }
  return '';
}

function parseDate(dateStr) {
  if (!dateStr) return null;
  // Append T12:00:00 to avoid UTC midnight timezone shift
  const d = new Date(dateStr + 'T12:00:00');
  return isNaN(d) ? null : d;
}

function formatDate(dateStr) {
  if (!dateStr) return '';
  const d = parseDate(dateStr);
  if (!d) return dateStr;
  const months = ['jan','feb','mar','apr','may','jun','jul','aug','sep','oct','nov','dec'];
  return months[d.getMonth()] + ' ' + d.getDate();
}

function escapeHtml(str) {
  if (!str) return '';
  return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
}

// ════════════════════════════════════════════
//  RENDER: DETAIL PANELS
// ════════════════════════════════════════════
function renderDetails(task, cssClass) {
  let html = '<div class="' + cssClass + '"><dl>';

  if (task.notes) {
    html += '<dt>Notes</dt><dd>' + escapeHtml(task.notes) + '</dd>';
  }
  if (task.blockers) {
    html += '<dt>Blockers</dt><dd style="color:var(--status-blocked)">' + escapeHtml(task.blockers) + '</dd>';
  }
  if (task.spec) {
    html += '<dt>Spec</dt><dd>' + escapeHtml(task.spec) + '</dd>';
  }
  if (task.nextSteps.length > 0) {
    html += '<dt>' + (task.status === 'done' ? 'Completed' : 'Next Steps') + '</dt><dd><ul>';
    task.nextSteps.forEach(function(s) {
      html += '<li>' + escapeHtml(s) + '</li>';
    });
    html += '</ul></dd>';
  }
  if (task.plannedCompletion) {
    html += '<dt>Planned</dt><dd>' + escapeHtml(task.plannedCompletion) + '</dd>';
  }
  if (task.actualCompletion) {
    html += '<dt>Completed</dt><dd>' + escapeHtml(task.actualCompletion) + '</dd>';
  }
  if (task.added) {
    html += '<dt>Added</dt><dd>' + escapeHtml(task.added) + '</dd>';
  }
  if (task.updated && task.updated !== task.added) {
    html += '<dt>Updated</dt><dd>' + escapeHtml(task.updated) + '</dd>';
  }

  html += '</dl></div>';
  return html;
}

// ════════════════════════════════════════════
//  RENDER: HEADER
// ════════════════════════════════════════════
function renderHeader() {
  const total = tasks.length;
  let latestDate = null;
  tasks.forEach(t => {
    if (t.updated) {
      const d = parseDate(t.updated);
      if (d && (!latestDate || d > latestDate)) latestDate = d;
    }
  });
  const months = ['jan','feb','mar','apr','may','jun','jul','aug','sep','oct','nov','dec'];
  const dateStr = latestDate
    ? months[latestDate.getMonth()] + ' ' + latestDate.getDate() + ', ' + latestDate.getFullYear()
    : 'unknown';
  document.getElementById('header-meta-text').textContent = total + ' tasks \u00B7 last updated ' + dateStr;

  // Data source badge
  const badge = document.getElementById('data-source-badge');
  if (dataSource === 'live') {
    badge.innerHTML = '<span class="data-source live"><span class="data-source-dot"></span>Live</span>';
  } else if (dataSource === 'embedded') {
    badge.innerHTML = '<span class="data-source embedded"><span class="data-source-dot"></span>Snapshot</span>';
  }
}

// ════════════════════════════════════════════
//  RENDER: SUMMARY ROW
// ════════════════════════════════════════════
function renderSummaryRow() {
  var statuses = ['progress', 'blocked', 'notstarted', 'done', 'draft'];
  var html = '<div class="summary-row">';
  statuses.forEach(function(s) {
    html += '<div class="summary-card" data-status="' + s + '">';
    html += '<div class="summary-label">' + statusLabels[s] + '</div>';
    html += '<div class="summary-value">' + countByStatus(s) + '</div>';
    html += '</div>';
  });
  html += '</div>';
  return html;
}

// ════════════════════════════════════════════
//  RENDER: KANBAN BOARD
// ════════════════════════════════════════════
function renderNoResults() {
  return '<div class="no-results">' +
    '<div class="no-results-icon">&#x2315;</div>' +
    '<div class="no-results-text">No tasks match current filters</div>' +
    '<div class="no-results-sub">Try adjusting your search or filters</div>' +
    '</div>';
}

function renderKanban() {
  var filtered = getFilteredTasks();
  var columns = ['notstarted', 'progress', 'blocked', 'done'];
  var drafts = filtered.filter(function(t) { return t.status === 'draft'; }).sort(function(a, b) { return a.priority - b.priority; });

  var html = renderSummaryRow();

  if (hasActiveFilters() && filtered.length === 0) {
    html += renderNoResults();
    document.getElementById('view-kanban').innerHTML = html;
    return;
  }

  html += '<div class="kanban-grid">';
  columns.forEach(function(col) {
    var colTasks = filtered.filter(function(t) { return t.status === col; }).sort(function(a, b) { return a.priority - b.priority; });
    html += '<div class="kanban-column" data-status="' + col + '">';
    html += '<div class="kanban-column-header">';
    html += '<span class="kanban-column-title">' + statusLabels[col] + '</span>';
    html += '<span class="kanban-column-count">' + colTasks.length + '</span>';
    html += '</div>';

    colTasks.forEach(function(task) {
      var date = getDisplayDate(task);
      html += '<div class="kanban-card" role="button" tabindex="0" aria-expanded="false" onclick="toggleCard(this)" onkeydown="handleCardKey(event,this)">';
      html += '<div class="kanban-card-title">' + escapeHtml(task.title) + '</div>';
      html += '<div class="kanban-card-meta">';
      html += '<span class="badge badge-p' + task.priority + '" style="font-size:0.62rem;padding:2px 6px;">' + priorityLabels[task.priority] + '</span>';
      html += '<span class="project-tag">' + escapeHtml(task.project) + '</span>';
      if (date) {
        html += '<span class="kanban-card-date">' + date + '</span>';
      }
      html += '</div>';
      html += renderDetails(task, 'card-details');
      html += '</div>';
    });

    html += '</div>';
  });
  html += '</div>';

  // Draft section
  if (drafts.length > 0) {
    html += '<div class="draft-section">';
    html += '<button class="draft-toggle" onclick="toggleDrafts(event)">';
    html += '<span class="draft-toggle-arrow">&#9654;</span>';
    html += 'Draft items (' + drafts.length + ') \u2014 not committed';
    html += '</button>';
    html += '<div class="draft-cards" id="draft-cards">';

    drafts.forEach(function(task) {
      html += '<div class="draft-card" role="button" tabindex="0" aria-expanded="false" onclick="toggleCard(this)" onkeydown="handleCardKey(event,this)">';
      html += '<div class="draft-card-title">' + escapeHtml(task.title) + '</div>';
      html += '<span class="badge badge-p' + task.priority + '" style="font-size:0.6rem;padding:2px 5px;">' + priorityLabels[task.priority] + '</span>';
      html += renderDetails(task, 'card-details');
      html += '</div>';
    });

    html += '</div></div>';
  }

  document.getElementById('view-kanban').innerHTML = html;
}

// ════════════════════════════════════════════
//  RENDER: COMMAND CENTER
// ════════════════════════════════════════════
function renderCommandCenter() {
  var filtered = getFilteredTasks();
  var statusOrder = ['done', 'progress', 'blocked', 'notstarted', 'draft'];
  var counts = {};
  statusOrder.forEach(function(s) { counts[s] = filtered.filter(function(t) { return t.status === s; }).length; });
  var total = filtered.length;
  var activeStatuses = statusOrder.filter(function(s) { return counts[s] > 0; });

  // Handle empty filtered results
  if (hasActiveFilters() && total === 0) {
    document.getElementById('view-command').innerHTML = renderNoResults();
    return;
  }

  // Status bar
  var html = '<div class="command-bar-section">';
  html += '<div class="status-bar-chart">';
  activeStatuses.forEach(function(s) {
    html += '<div class="status-bar-segment" data-status="' + s + '" style="flex:' + counts[s] + ';">' + counts[s] + '</div>';
  });
  html += '</div>';

  var gridCols = activeStatuses.map(function(s) { return counts[s] + 'fr'; }).join(' ');
  html += '<div style="display:grid;grid-template-columns:' + gridCols + ';gap:2px;margin-top:6px;">';
  var shortLabels = { done: 'Done', progress: 'In Progress', blocked: 'Blk', notstarted: 'Not Started', draft: 'Draft' };
  activeStatuses.forEach(function(s) {
    html += '<div class="bar-label">' + shortLabels[s] + '</div>';
  });
  html += '</div></div>';

  // Layout
  html += '<div class="command-layout">';

  // Task list
  var sorted = filtered.slice().sort(function(a, b) {
    var sw = { progress: 0, blocked: 1, notstarted: 2, draft: 3, done: 4 };
    var d = (sw[a.status] || 5) - (sw[b.status] || 5);
    if (d !== 0) return d;
    return a.priority - b.priority;
  });

  html += '<div class="task-list-panel">';
  html += '<div class="task-list-header">';
  html += '<span class="task-list-title">All Tasks (by priority)</span>';
  html += '<span class="task-list-count">' + total + ' items</span>';
  html += '</div>';

  sorted.forEach(function(task) {
    var isDone = task.status === 'done';
    var date = getDisplayDate(task);
    html += '<div class="task-list-item' + (isDone ? ' is-done' : '') + '" role="button" tabindex="0" aria-expanded="false" onclick="toggleRow(this)" onkeydown="handleCardKey(event,this)">';
    html += '<span class="task-list-priority" style="color:var(--p' + task.priority + ')">' + priorityLabels[task.priority] + '</span>';
    html += '<span class="task-list-name">' + escapeHtml(task.title) + '</span>';
    html += '<span class="badge badge-' + task.status + '" style="font-size:0.62rem;padding:2px 6px;"><span class="badge-dot"></span>' + statusCommandLabels[task.status] + '</span>';
    html += '<span class="task-list-date">' + (date || '') + '</span>';
    html += '<span class="project-tag">' + escapeHtml(task.project) + '</span>';
    html += renderDetails(task, 'row-details');
    html += '</div>';
  });

  html += '</div>';

  // Stats panel
  html += '<div class="stats-panel">';

  // Priority distribution (based on filtered tasks)
  var filteredPriorityCounts = {};
  [1,2,3,4,5].forEach(function(p) {
    filteredPriorityCounts[p] = filtered.filter(function(t) { return t.priority === p; }).length;
  });
  var maxP = Math.max.apply(null, [1,2,3,4,5].map(function(p) { return filteredPriorityCounts[p]; }));
  html += '<div class="stat-block">';
  html += '<div class="stat-block-title">Priority Distribution</div>';
  html += '<div class="h-bar-chart">';
  [1,2,3,4,5].forEach(function(p) {
    var count = filteredPriorityCounts[p];
    var pct = maxP > 0 ? Math.round((count / maxP) * 100) : 0;
    html += '<div class="h-bar-row">';
    html += '<span class="h-bar-label" style="color:var(--p' + p + ')">P' + p + '</span>';
    html += '<div class="h-bar-track"><div class="h-bar-fill" style="width:' + pct + '%;background:var(--p' + p + ');' + (p >= 4 ? 'opacity:0.6;' : '') + '"></div></div>';
    html += '<span class="h-bar-value">' + count + '</span>';
    html += '</div>';
  });
  html += '</div></div>';

  // Projects (from filtered tasks)
  var projectMap = {};
  filtered.forEach(function(t) {
    var p = t.project || 'unknown';
    projectMap[p] = (projectMap[p] || 0) + 1;
  });
  var projects = Object.entries(projectMap).sort(function(a, b) { return b[1] - a[1]; });
  var maxProj = projects.length > 0 ? projects[0][1] : 1;
  html += '<div class="stat-block">';
  html += '<div class="stat-block-title">By Project</div>';
  html += '<div class="project-breakdown">';
  projects.forEach(function(entry) {
    var name = entry[0], count = entry[1];
    var pct = Math.round((count / maxProj) * 100);
    html += '<div class="project-row">';
    html += '<span class="project-name">' + escapeHtml(name) + '</span>';
    html += '<div class="project-count">';
    html += '<div class="project-bar-mini"><div class="project-bar-mini-fill" style="width:' + pct + '%;"></div></div>';
    html += '<span class="project-count-num">' + count + '</span>';
    html += '</div></div>';
  });
  html += '</div></div>';

  // Aging (from filtered tasks)
  var now = new Date();
  var aging = filtered
    .filter(function(t) { return t.status !== 'done' && t.status !== 'draft' && t.added; })
    .map(function(t) {
      var added = parseDate(t.added);
      var days = added ? Math.floor((now - added) / (1000 * 60 * 60 * 24)) : 0;
      return { title: t.title, status: t.status, ageDays: days };
    })
    .sort(function(a, b) { return b.ageDays - a.ageDays; })
    .slice(0, 5);
  if (aging.length > 0) {
    html += '<div class="stat-block">';
    html += '<div class="stat-block-title">Aging (oldest first)</div>';
    html += '<div class="aging-list">';
    aging.forEach(function(t) {
      var cls = t.ageDays >= 7 ? 'critical' : t.ageDays >= 3 ? 'warn' : '';
      var suffix = t.status === 'blocked' ? ' \u25CF' : '';
      var truncTitle = t.title.length > 24 ? t.title.slice(0, 24) + '...' : t.title;
      html += '<div class="aging-item">';
      html += '<span class="aging-task">' + escapeHtml(truncTitle) + '</span>';
      html += '<span class="aging-days ' + cls + '">' + t.ageDays + 'd' + suffix + '</span>';
      html += '</div>';
    });
    html += '</div></div>';
  }

  html += '</div>'; // stats-panel
  html += '</div>'; // command-layout

  document.getElementById('view-command').innerHTML = html;
}

// ════════════════════════════════════════════
//  INTERACTIONS
// ════════════════════════════════════════════
function switchView(view) {
  const validViews = ['kanban', 'command', 'pipeline', 'workers'];
  if (!validViews.includes(view)) return;
  document.querySelectorAll('.tab').forEach(function(t) { t.classList.remove('active'); });
  document.querySelectorAll('.view').forEach(function(v) { v.classList.remove('active'); });
  document.querySelector('[data-view="' + view + '"]').classList.add('active');
  document.getElementById('view-' + view).classList.add('active');
}

function toggleDrafts(e) {
  e.stopPropagation();
  var btn = document.querySelector('.draft-toggle');
  var cards = document.getElementById('draft-cards');
  btn.classList.toggle('open');
  cards.classList.toggle('open');
}

function toggleExpand(el) {
  var isExpanded = el.classList.toggle('expanded');
  el.setAttribute('aria-expanded', isExpanded ? 'true' : 'false');
}

function toggleCard(el) {
  toggleExpand(el);
}

function toggleRow(el) {
  toggleExpand(el);
}

function handleCardKey(e, el) {
  if (e.key === 'Enter' || e.key === ' ') {
    e.preventDefault();
    toggleExpand(el);
  }
}

// ════════════════════════════════════════════
//  FILTERING
// ════════════════════════════════════════════
const currentFilters = {
  text: '',
  status: '',
  priority: '',
  project: '',
};

function getFilteredTasks() {
  return tasks.filter(function(t) {
    // Text search: match title, notes, project, blockers
    if (currentFilters.text) {
      const q = currentFilters.text.toLowerCase();
      const haystack = [t.title, t.notes, t.project, t.blockers || '']
        .join(' ').toLowerCase();
      if (haystack.indexOf(q) === -1) return false;
    }
    // Status filter
    if (currentFilters.status && t.status !== currentFilters.status) return false;
    // Priority filter
    if (currentFilters.priority && t.priority !== parseInt(currentFilters.priority)) return false;
    // Project filter
    if (currentFilters.project && (t.project || '').toLowerCase() !== currentFilters.project.toLowerCase()) return false;
    return true;
  });
}

function hasActiveFilters() {
  return currentFilters.text !== '' || currentFilters.status !== '' || currentFilters.priority !== '' || currentFilters.project !== '';
}

function updateFilterUI() {
  var filtered = getFilteredTasks();
  var countEl = document.getElementById('filter-count');
  var clearBtn = document.getElementById('filter-clear');

  if (hasActiveFilters()) {
    countEl.innerHTML = '<strong>' + filtered.length + '</strong> of ' + tasks.length + ' tasks';
    clearBtn.classList.add('visible');
  } else {
    countEl.textContent = '';
    clearBtn.classList.remove('visible');
  }

  // Mark selects as active when a filter is chosen
  document.getElementById('filter-status').classList.toggle('active', currentFilters.status !== '');
  document.getElementById('filter-priority').classList.toggle('active', currentFilters.priority !== '');
  document.getElementById('filter-project').classList.toggle('active', currentFilters.project !== '');
}

function applyFilters() {
  updateFilterUI();
  renderKanban();
  renderCommandCenter();
}

function clearFilters() {
  currentFilters.text = '';
  currentFilters.status = '';
  currentFilters.priority = '';
  currentFilters.project = '';
  document.getElementById('filter-text').value = '';
  document.getElementById('filter-status').value = '';
  document.getElementById('filter-priority').value = '';
  document.getElementById('filter-project').value = '';
  applyFilters();
}

// Bind filter inputs
document.getElementById('filter-text').addEventListener('input', function(e) {
  currentFilters.text = e.target.value;
  applyFilters();
});

document.getElementById('filter-status').addEventListener('change', function(e) {
  currentFilters.status = e.target.value;
  applyFilters();
});

document.getElementById('filter-priority').addEventListener('change', function(e) {
  currentFilters.priority = e.target.value;
  applyFilters();
});

document.getElementById('filter-project').addEventListener('change', function(e) {
  currentFilters.project = e.target.value;
  applyFilters();
});

// Keyboard shortcuts
document.addEventListener('keydown', function(e) {
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;
  if (e.key === 'b' || e.key === 'B') switchView('kanban');
  if (e.key === 'c' || e.key === 'C') switchView('command');
  if (e.key === 'p' || e.key === 'P') switchView('pipeline');
  if (e.key === 'w' || e.key === 'W') switchView('workers');
  if (e.key === 'r' || e.key === 'R') refreshData();
  if (e.key === '/') {
    e.preventDefault();
    document.getElementById('filter-text').focus();
  }
  if (e.key === 'Escape') {
    if (hasActiveFilters()) {
      clearFilters();
    }
  }
});

// Allow Escape from search input to blur and clear
document.getElementById('filter-text').addEventListener('keydown', function(e) {
  if (e.key === 'Escape') {
    e.target.blur();
    if (hasActiveFilters()) clearFilters();
  }
});

// ════════════════════════════════════════════
//  DATA LOADING & REFRESH
// ════════════════════════════════════════════
function showError(message) {
  const container = document.getElementById('error-container');
  container.innerHTML = '<div class="error-banner">' +
    '<span>' + escapeHtml(message) + '</span>' +
    '<button class="error-banner-dismiss" onclick="this.parentElement.remove()" aria-label="Dismiss">&times;</button>' +
    '</div>';
}

function clearErrors() {
  document.getElementById('error-container').innerHTML = '';
}

function populateProjectFilter() {
  var select = document.getElementById('filter-project');
  var current = select.value;
  var projects = [];
  var seen = {};
  tasks.forEach(function(t) {
    var p = t.project || 'unknown';
    if (!seen[p]) {
      seen[p] = true;
      projects.push(p);
    }
  });
  projects.sort();
  select.innerHTML = '<option value="">All projects</option>';
  projects.forEach(function(p) {
    var opt = document.createElement('option');
    opt.value = p;
    opt.textContent = p;
    select.appendChild(opt);
  });
  // Restore previous selection if still valid
  if (current && seen[current]) {
    select.value = current;
  }
}

function renderAll() {
  populateProjectFilter();
  renderHeader();
  updateFilterUI();
  renderKanban();
  renderCommandCenter();
}

async function loadBacklog() {
  try {
    // Step 1: Get list of task files
    const listRes = await fetch(TASKS_API);
    if (!listRes.ok) throw new Error('HTTP ' + listRes.status);
    const fileNames = await listRes.json();

    // Step 2: Fetch each task file in parallel
    const fetches = fileNames.map(name =>
      fetch(TASKS_DIR + name).then(r => {
        if (!r.ok) throw new Error('HTTP ' + r.status + ' for ' + name);
        return r.text();
      })
    );
    const contents = await Promise.all(fetches);

    // Step 3: Parse each file
    tasks = contents.map(parseTaskFile).filter(Boolean);
    dataSource = 'live';
    return true;
  } catch (e) {
    // Fallback to embedded data
    if (FALLBACK_TASKS.length > 0) {
      tasks = FALLBACK_TASKS;
      dataSource = 'embedded';
    } else {
      tasks = [];
      dataSource = 'none';
    }
    return false;
  }
}

let isRefreshing = false;
async function refreshData() {
  if (isRefreshing) return;
  isRefreshing = true;
  const btn = document.getElementById('refresh-btn');
  btn.classList.add('spinning');
  btn.textContent = 'Loading...';
  clearErrors();

  const wasLive = await loadBacklog();
  renderAll();

  if (!wasLive && dataSource === 'embedded') {
    showError('Could not fetch live data — showing embedded snapshot. Use a local server for live loading.');
  }

  btn.classList.remove('spinning');
  btn.textContent = 'Refresh';
  isRefreshing = false;
}

// ════════════════════════════════════════════
//  PIPELINE & WORKERS: SSE + DATA FETCHING
// ════════════════════════════════════════════
let sseConnection = null;
let sseLastEventTime = null;
let sseTimerInterval = null;
let pipelineDispatches = [];
let pipelineState = null;
let workersData = [];

function connectSSE() {
  if (sseConnection) {
    sseConnection.close();
  }
  try {
    sseConnection = new EventSource('/api/events');
    const indicator = document.getElementById('sse-indicator');
    const dot = document.getElementById('sse-dot');
    const label = document.getElementById('sse-label');

    sseConnection.onopen = function() {
      indicator.style.display = '';
      dot.classList.remove('disconnected');
      label.textContent = 'live';
      sseLastEventTime = Date.now();
    };

    // Handle named events from SSE
    sseConnection.addEventListener('dispatches:changed', function() {
      sseLastEventTime = Date.now();
      fetchPipelineData();
    });
    sseConnection.addEventListener('results:changed', function() {
      sseLastEventTime = Date.now();
      fetchPipelineData();
    });
    sseConnection.addEventListener('blockers:changed', function() {
      sseLastEventTime = Date.now();
      fetchPipelineData();
    });
    sseConnection.addEventListener('state:changed', function() {
      sseLastEventTime = Date.now();
      fetchPipelineData();
    });
    sseConnection.addEventListener('workers:update', function(e) {
      sseLastEventTime = Date.now();
      try {
        const data = JSON.parse(e.data);
        workersData = data.workers || [];
        workersData.forEach(function(w) {
          if (typeof w.output === 'string') w.output = w.output.split('\n');
          if (!w.status) w.status = w.active ? 'active' : 'idle';
          if (typeof w.elapsed === 'string') {
            const hMatch = w.elapsed.match(/(\d+)h/);
            const mMatch = w.elapsed.match(/(\d+)m/);
            w.elapsed = (hMatch ? parseInt(hMatch[1]) * 3600 : 0) + (mMatch ? parseInt(mMatch[1]) * 60 : 0);
          }
        });
        renderWorkers(workersData);
      } catch (err) {}
    });
    // Fallback for generic messages
    sseConnection.onmessage = function(e) {
      sseLastEventTime = Date.now();
    };

    sseConnection.onerror = function() {
      dot.classList.add('disconnected');
      label.textContent = 'disconnected';
      // Auto-reconnect after 5s
      setTimeout(function() {
        if (sseConnection && sseConnection.readyState === EventSource.CLOSED) {
          connectSSE();
        }
      }, 5000);
    };

    // Update SSE timer every second
    if (sseTimerInterval) clearInterval(sseTimerInterval);
    sseTimerInterval = setInterval(function() {
      if (sseLastEventTime) {
        const ago = Math.floor((Date.now() - sseLastEventTime) / 1000);
        label.textContent = 'last event ' + ago + 's ago';
      }
    }, 1000);
  } catch (e) {
    // SSE not available (file:// protocol, etc.)
  }
}

async function fetchPipelineData() {
  try {
    const [dispatchRes, stateRes] = await Promise.all([
      fetch('/api/dispatches').then(r => r.ok ? r.json() : { dispatches: [], results: [], blockers: [] }),
      fetch('/api/handler-state').then(r => r.ok ? r.json() : null),
    ]);
    // Merge results and blockers into dispatch objects
    const dispatchData = dispatchRes.dispatches || [];
    const results = dispatchRes.results || [];
    const blockers = dispatchRes.blockers || [];

    // Create lookup maps
    const resultMap = {};
    results.forEach(function(r) {
      // Match result to dispatch by id prefix
      const dispId = r.dispatch || r.id;
      resultMap[dispId] = r;
    });
    const blockerMap = {};
    blockers.forEach(function(b) {
      const dispId = b.dispatch || b.id;
      blockerMap[dispId] = b;
    });

    // Enrich dispatch objects
    dispatchData.forEach(function(d) {
      if (resultMap[d.id]) {
        d.result = resultMap[d.id];
        d.status = 'completed';
      }
      if (blockerMap[d.id]) {
        d.blocker = blockerMap[d.id].blocker || blockerMap[d.id].title;
        d.status = d.status || 'blocked';
      }
      // Extract fields from metadata if present
      if (d.metadata) {
        if (!d.project && d.metadata.project) d.project = d.metadata.project;
        if (!d.priority && d.metadata.priority) {
          const pm = d.metadata.priority.match(/(\d)/);
          if (pm) d.priority = parseInt(pm[1]);
        }
        if (d.metadata.needs_user_review && /yes/i.test(d.metadata.needs_user_review)) {
          d.needsReview = true;
        }
        if (d.metadata.worker) d.workerName = d.metadata.worker;
        if (d.metadata.status) {
          const ms = d.metadata.status.toLowerCase();
          if (ms.includes('active') || ms.includes('running')) d.status = d.status || 'active';
          if (ms.includes('queued') || ms.includes('pending')) d.status = d.status || 'queued';
        }
      }
    });

    pipelineDispatches = dispatchData;
    pipelineState = parseHandlerState(stateRes);
    renderPipeline(pipelineDispatches, pipelineState);
  } catch (e) {
    // Silently fail if APIs not available
  }
}

function parseHandlerState(stateRes) {
  if (!stateRes) return null;
  const state = {};
  const sections = stateRes.sections || [];
  const raw = stateRes.raw || '';

  // Parse budget info
  const budgetSection = sections.find(s => /budget/i.test(s.title));
  if (budgetSection) {
    state.budget = {};
    const pctMatch = budgetSection.content.match(/(\d+(?:\.\d+)?)%/);
    if (pctMatch) state.budget.percentUsed = parseFloat(pctMatch[1]);
    const daysMatch = budgetSection.content.match(/(\d+(?:\.\d+)?)\s*days?\s*remaining/i);
    if (daysMatch) state.budget.daysRemaining = parseFloat(daysMatch[1]);
    if (/under[- ]?paced/i.test(budgetSection.content)) state.budget.pace = 'under-paced';
    else if (/over[- ]?paced/i.test(budgetSection.content)) state.budget.pace = 'over-paced';
    else if (/on[- ]?track/i.test(budgetSection.content)) state.budget.pace = 'on-track';
    const targetMatch = budgetSection.content.match(/target[:\s]*(\d+(?:\.\d+)?)%/i);
    if (targetMatch) state.budget.targetPercent = parseFloat(targetMatch[1]);
  }

  // Parse pending decisions
  const decSection = sections.find(s => /pending\s*decision/i.test(s.title));
  if (decSection) {
    state.decisions = [];
    // Parse table rows: | ID | Title | Reason | Cost |
    const rows = decSection.content.matchAll(/\|\s*([^|]+)\s*\|\s*([^|]+)\s*\|\s*([^|]+)\s*\|(?:\s*([^|]+)\s*\|)?/g);
    for (const row of rows) {
      const id = row[1].trim();
      const title = row[2].trim();
      if (id.startsWith('---') || id.toLowerCase() === 'id' || /^\*\*/.test(id)) continue;
      state.decisions.push({
        dispatchId: id,
        title: title,
        reason: row[3] ? row[3].trim() : 'user review',
        cost: row[4] ? row[4].trim() : null,
      });
    }
  }

  // Parse queued dispatches for "Needs User Review?" column
  const queuedSection = sections.find(s => /queued\s*dispatch/i.test(s.title));
  if (queuedSection) {
    const qRows = queuedSection.content.matchAll(/\|\s*([^|]+)\s*\|\s*([^|]+)\s*\|\s*([^|]+)\s*\|\s*([^|]+)\s*\|\s*([^|]+)\s*\|/g);
    if (!state.decisions) state.decisions = [];
    for (const row of qRows) {
      const id = row[1].trim();
      if (id.startsWith('---') || id.toLowerCase() === 'id' || /^\*\*/.test(id)) continue;
      const needsReview = row[5] ? row[5].trim() : '';
      if (/yes/i.test(needsReview)) {
        if (!state.decisions.find(d => d.dispatchId === id)) {
          state.decisions.push({
            dispatchId: id,
            title: row[2] ? row[2].trim() : id,
            reason: 'user review',
          });
        }
      }
    }
  }

  // Parse active dispatches
  const activeSection = sections.find(s => /active\s*dispatch/i.test(s.title));
  if (activeSection) {
    state.activeDispatches = [];
    const aRows = activeSection.content.matchAll(/\|\s*([^|]+)\s*\|\s*([^|]+)\s*\|/g);
    for (const row of aRows) {
      const id = row[1].trim();
      if (id.startsWith('---') || id.toLowerCase() === 'id' || /^\*\*/.test(id)) continue;
      state.activeDispatches.push({ id });
    }
  }

  // Parse projects if available
  const projSection = sections.find(s => /project|priority\s*align/i.test(s.title));
  if (projSection) {
    state.projects = [];
    const pRows = projSection.content.matchAll(/\|\s*([^|]+)\s*\|\s*([^|]+)\s*\|\s*([^|]+)\s*\|/g);
    for (const row of pRows) {
      const name = row[1].trim();
      if (name.startsWith('---') || name.toLowerCase() === 'project' || /^\*\*/.test(name)) continue;
      const priMatch = row[2].trim().match(/(\d)/);
      state.projects.push({
        name,
        priority: priMatch ? parseInt(priMatch[1]) : 5,
        status: row[3] ? row[3].trim() : '',
      });
    }
  }

  return state;
}

async function fetchWorkers() {
  try {
    const res = await fetch('/api/workers');
    if (res.ok) {
      const data = await res.json();
      workersData = data.workers || [];
      // Parse output strings into arrays if needed
      workersData.forEach(function(w) {
        if (typeof w.output === 'string') {
          w.output = w.output.split('\n');
        }
        if (!w.status) w.status = w.active ? 'active' : 'idle';
        if (typeof w.elapsed === 'string') {
          // Convert "12m" or "1h 5m" to seconds for formatElapsed
          const hMatch = w.elapsed.match(/(\d+)h/);
          const mMatch = w.elapsed.match(/(\d+)m/);
          w.elapsed = (hMatch ? parseInt(hMatch[1]) * 3600 : 0) + (mMatch ? parseInt(mMatch[1]) * 60 : 0);
        }
      });
      renderWorkers(workersData);
    }
  } catch (e) {
    // Silently fail
  }
}

// ════════════════════════════════════════════
//  PIPELINE: RENDERING
// ════════════════════════════════════════════
function formatElapsed(seconds) {
  if (!seconds && seconds !== 0) return '';
  const m = Math.floor(seconds / 60);
  const s = Math.floor(seconds % 60);
  return m + 'm ' + s + 's';
}

function formatTimeAgo(dateStr) {
  if (!dateStr) return '';
  const then = new Date(dateStr);
  const now = Date.now();
  const diffMs = now - then.getTime();
  if (diffMs < 0) return 'just now';
  const diffMin = Math.floor(diffMs / 60000);
  if (diffMin < 60) return diffMin + 'm ago';
  const diffH = Math.floor(diffMin / 60);
  if (diffH < 24) return diffH + 'h ago';
  const diffD = Math.floor(diffH / 24);
  return diffD + 'd ago';
}

function renderPipeline(dispatches, state) {
  // --- Budget bar ---
  const budgetPct = document.querySelector('#view-pipeline .budget-pct');
  const budgetFill = document.querySelector('#view-pipeline .budget-bar-fill');
  const budgetDetail = document.querySelector('#view-pipeline .budget-detail');
  const budgetTarget = document.querySelector('#view-pipeline .budget-bar-target');
  const budgetTargetLabel = document.querySelector('#view-pipeline .budget-bar-target-label');

  if (state && state.budget) {
    const b = state.budget;
    const pct = b.percentUsed || 0;
    budgetPct.textContent = pct + '%';
    budgetFill.style.width = Math.min(pct, 100) + '%';
    const detail = [];
    if (b.daysRemaining != null) detail.push(b.daysRemaining + ' days remaining');
    if (b.pace) {
      const cls = b.pace === 'over-paced' ? 'over' : 'under';
      detail.push('<span class="' + cls + '">' + escapeHtml(b.pace) + '</span>');
    }
    budgetDetail.innerHTML = detail.join(' &middot; ');
    if (b.targetPercent != null) {
      budgetTarget.style.width = b.targetPercent + '%';
      budgetTargetLabel.textContent = 'target ' + b.targetPercent + '%';
    }
  } else {
    budgetPct.textContent = '--';
    budgetFill.style.width = '0%';
    budgetDetail.textContent = 'No budget data';
  }

  // --- Decisions panel ---
  const decisionsList = document.getElementById('decisions-list');
  const decisions = [];

  // From state.decisions if available
  if (state && state.decisions && Array.isArray(state.decisions)) {
    state.decisions.forEach(function(d) { decisions.push(d); });
  }

  // Also check dispatches flagged as needing review
  dispatches.forEach(function(d) {
    if (d.needsReview && !decisions.find(dec => dec.dispatchId === d.id)) {
      decisions.push({
        dispatchId: d.id,
        title: d.title || d.objective || 'Review dispatch',
        reason: 'user review',
        cost: d.estimatedCost || null,
        project: d.project,
        links: d.links || [],
        evidence: d.evidence || null,
      });
    }
  });

  const countLabel = document.getElementById('decisions-count-label');
  countLabel.textContent = decisions.length + ' decision' + (decisions.length !== 1 ? 's' : '') + ' awaiting approval';

  // Update pipeline badge
  const pipelineBadge = document.getElementById('pipeline-badge');
  if (decisions.length > 0) {
    pipelineBadge.textContent = decisions.length;
    pipelineBadge.style.display = '';
  } else {
    pipelineBadge.style.display = 'none';
  }

  let decHtml = '';
  decisions.forEach(function(d, i) {
    const proj = d.project || '';
    const priority = d.priority || '';
    decHtml += '<div class="decision-item" data-project="' + escapeHtml(proj) + '" data-priority="' + escapeHtml(priority) + '" onclick="this.classList.toggle(\'expanded\')">';
    decHtml += '<div class="decision-top">';
    decHtml += '<div class="decision-number">#' + (i + 1) + '</div>';
    decHtml += '<div class="decision-content">';
    decHtml += '<div class="decision-desc">';
    decHtml += '<span class="decision-desc-text">' + escapeHtml(d.title) + '</span>';
    if (d.reason) {
      const reasonClass = d.reason === 'irreversible' ? 'irreversible' : d.reason === 'budget' ? 'budget' : 'user-review';
      decHtml += ' <span class="decision-reason ' + reasonClass + '">' + escapeHtml(d.reason) + '</span>';
    }
    if (d.cost) {
      decHtml += ' <span class="decision-cost">~' + escapeHtml(d.cost) + '</span>';
    }
    decHtml += '</div>'; // decision-desc

    if (d.links && d.links.length > 0) {
      decHtml += '<div class="decision-links">';
      d.links.forEach(function(link) {
        if (link.description) decHtml += '<span class="link-desc">' + escapeHtml(link.description) + '</span> ';
        if (link.type === 'server') {
          decHtml += '<button class="start-server-btn" onclick="event.stopPropagation(); startPreviewServer(\'' + escapeHtml(link.path || '') + '\', ' + (link.port || 3000) + ', this)">&#9656; Start preview server</button>';
        } else if (link.url) {
          decHtml += '<a class="decision-link" href="' + escapeHtml(link.url) + '" target="_blank">' + escapeHtml(link.label || link.url) + '</a>';
        }
      });
      decHtml += '</div>';
    }

    decHtml += '</div>'; // decision-content
    decHtml += '<div class="decision-actions">';
    const dispId = d.dispatchId || d.id || '';
    decHtml += '<button class="decision-btn yes" onclick="event.stopPropagation(); approveDispatch(\'' + escapeHtml(dispId) + '\')">Approve</button>';
    decHtml += '<button class="decision-btn no" onclick="event.stopPropagation(); rejectDispatch(\'' + escapeHtml(dispId) + '\')">Deny</button>';
    decHtml += '<button class="decision-btn rework" onclick="event.stopPropagation(); toggleRework(this)">Rework</button>';
    decHtml += '</div>';
    decHtml += '</div>'; // decision-top

    // Evidence section
    decHtml += '<div class="decision-evidence">';
    if (d.evidence) {
      if (d.evidence.verification) {
        decHtml += '<div class="evidence-section"><div class="evidence-label">Verification</div><div class="evidence-text">' + d.evidence.verification + '</div></div>';
      }
      if (d.evidence.risks) {
        decHtml += '<div class="evidence-section"><div class="evidence-label">Risks &amp; mitigations</div><div class="evidence-text">' + d.evidence.risks + '</div></div>';
      }
      if (d.evidence.description) {
        decHtml += '<div class="evidence-section"><div class="evidence-label">What worker will do</div><div class="evidence-text">' + escapeHtml(d.evidence.description) + '</div></div>';
      }
    }
    decHtml += '</div>'; // decision-evidence

    // Rework input
    decHtml += '<div class="rework-input">';
    decHtml += '<textarea placeholder="Describe what needs to change..."></textarea>';
    decHtml += '<button class="send-btn" onclick="event.stopPropagation(); reworkDispatch(\'' + escapeHtml(dispId) + '\', this.parentElement.querySelector(\'textarea\').value)">Send feedback</button>';
    decHtml += '</div>';

    decHtml += '</div>'; // decision-item
  });
  decisionsList.innerHTML = decHtml;

  // --- Categorize dispatches into kanban columns ---
  const activeIds = new Set();
  if (state && state.activeDispatches) {
    state.activeDispatches.forEach(function(d) { activeIds.add(d.id || d); });
  }

  const categorized = { queued: [], active: [], blocked: [], completed: [] };
  dispatches.forEach(function(d) {
    if (d.result || d.status === 'completed') {
      categorized.completed.push(d);
    } else if (d.blocker || d.status === 'blocked') {
      categorized.blocked.push(d);
    } else if (activeIds.has(d.id) || d.status === 'active' || d.workerName) {
      categorized.active.push(d);
    } else {
      categorized.queued.push(d);
    }
  });

  // Render kanban columns
  document.querySelectorAll('.dispatch-column').forEach(function(col) {
    const status = col.dataset.status;
    const cards = categorized[status] || [];
    col.querySelector('.count').textContent = cards.length;

    let html = '';
    cards.forEach(function(d) {
      const proj = d.project || '';
      const pri = d.priority ? 'p' + d.priority : '';
      const priLabel = d.priority ? 'P' + d.priority : '';
      const isCompleted = status === 'completed';
      const isBlocked = status === 'blocked';

      html += '<div class="dispatch-card" data-project="' + escapeHtml(proj) + '" data-priority="' + escapeHtml(pri) + '"';
      if (isCompleted) html += ' style="opacity:0.75;"';
      if (isBlocked) html += ' style="border-color:rgba(248,81,73,0.2);"';
      html += ' onclick="this.classList.toggle(\'expanded\')">';

      html += '<div class="card-top">';
      html += '<span class="card-project">' + escapeHtml(proj) + '</span>';
      if (isCompleted && d.result) {
        const badge = d.result.pr ? 'pr-ready' : 'success';
        const label = d.result.pr ? 'PR #' + d.result.pr : '&#10003; done';
        html += '<span class="result-badge ' + badge + '">' + label + '</span>';
      } else if (priLabel) {
        html += '<span class="card-priority ' + pri + '">' + priLabel + '</span>';
      }
      html += '</div>';

      html += '<div class="card-title">' + escapeHtml(d.title || d.objective || 'Untitled') + '</div>';

      html += '<div class="card-meta">';
      if (status === 'active' && d.startedAt) {
        const elapsed = Math.floor((Date.now() - new Date(d.startedAt).getTime()) / 1000);
        html += '<span style="color:var(--status-progress);">running ' + formatElapsed(elapsed) + '</span>';
        if (d.workerName) html += '<span>' + escapeHtml(d.workerName) + '</span>';
      } else if (status === 'blocked') {
        html += '<span style="color:var(--status-blocked);">blocked ' + formatTimeAgo(d.blockedAt || d.updatedAt) + '</span>';
      } else if (status === 'completed') {
        html += '<span>completed ' + formatTimeAgo(d.completedAt || d.updatedAt) + '</span>';
      } else {
        html += '<span>queued ' + formatTimeAgo(d.createdAt) + '</span>';
      }
      html += '</div>';

      // Expandable details
      html += '<dl class="card-details">';
      if (d.objective) { html += '<dt>Objective</dt><dd>' + escapeHtml(d.objective) + '</dd>'; }
      if (d.blocker) { html += '<dt>Blocker</dt><dd style="color:var(--status-blocked);">' + escapeHtml(d.blocker) + '</dd>'; }
      if (d.result && d.result.summary) { html += '<dt>Result</dt><dd>' + escapeHtml(d.result.summary) + '</dd>'; }
      html += '</dl>';

      if (!isCompleted) {
        html += '<div class="card-actions">';
        html += '<button class="stop-btn" onclick="event.stopPropagation(); stopDispatch(\'' + escapeHtml(d.id) + '\', \'' + escapeHtml(d.workerName || '') + '\')">Stop</button>';
        html += '</div>';
      }

      html += '</div>'; // dispatch-card
    });
    col.querySelector('.column-cards').innerHTML = html;
  });

  // Update workers badge with active count
  const workersBadge = document.getElementById('workers-badge');
  const activeCount = categorized.active.length;
  if (activeCount > 0) {
    workersBadge.textContent = activeCount;
    workersBadge.style.display = '';
  } else {
    workersBadge.style.display = 'none';
  }

  // --- Priority alignment table ---
  const tbody = document.getElementById('priority-body');
  const projectStats = {};
  dispatches.forEach(function(d) {
    const p = d.project || 'unknown';
    if (!projectStats[p]) projectStats[p] = { priority: d.priority || 5, active: 0, queued: 0, blocked: 0, completed: 0 };
    if (categorized.active.includes(d)) projectStats[p].active++;
    else if (categorized.queued.includes(d)) projectStats[p].queued++;
    else if (categorized.blocked.includes(d)) projectStats[p].blocked++;
    else if (categorized.completed.includes(d)) projectStats[p].completed++;
    // Use lowest (highest priority) number
    if (d.priority && d.priority < projectStats[p].priority) projectStats[p].priority = d.priority;
  });

  // Also include projects from state if available
  if (state && state.projects) {
    state.projects.forEach(function(proj) {
      if (!projectStats[proj.name]) {
        projectStats[proj.name] = { priority: proj.priority || 5, active: 0, queued: 0, blocked: 0, completed: 0 };
      }
      if (proj.status) projectStats[proj.name].statusText = proj.status;
    });
  }

  let tbodyHtml = '';
  const sortedProjects = Object.entries(projectStats).sort(function(a, b) { return a[1].priority - b[1].priority; });
  sortedProjects.forEach(function(entry) {
    const name = entry[0];
    const s = entry[1];
    const pri = 'p' + s.priority;
    let statusText = s.statusText || '';
    let statusColor = 'var(--text-dim)';
    if (s.blocked > 0) { statusText = statusText || 'blocked'; statusColor = 'var(--status-blocked)'; }
    else if (s.active > 0) { statusText = statusText || 'healthy'; statusColor = 'var(--status-done)'; }
    else if (s.queued > 0) { statusText = statusText || 'queued'; statusColor = 'var(--status-queued)'; }
    else { statusText = statusText || 'idle'; }

    tbodyHtml += '<tr data-project="' + escapeHtml(name) + '" data-priority="' + pri + '">';
    tbodyHtml += '<td>' + escapeHtml(name) + '</td>';
    tbodyHtml += '<td><span class="project-priority" style="color:var(--' + pri + ');">P' + s.priority + '</span></td>';
    tbodyHtml += '<td>' + s.active + '</td>';
    tbodyHtml += '<td>' + s.queued + '</td>';
    tbodyHtml += '<td style="color:' + statusColor + ';">' + escapeHtml(statusText) + '</td>';
    tbodyHtml += '</tr>';
  });
  tbody.innerHTML = tbodyHtml;

  // Populate project filter dropdown
  populatePipelineProjectFilter(dispatches);

  // Apply any active filters
  applyPipelineFilters();
}

function populatePipelineProjectFilter(dispatches) {
  const select = document.getElementById('pipeline-filter-project');
  const current = select.value;
  const projects = new Set();
  dispatches.forEach(function(d) { if (d.project) projects.add(d.project); });
  select.innerHTML = '<option value="">All projects</option>';
  Array.from(projects).sort().forEach(function(p) {
    const opt = document.createElement('option');
    opt.value = p;
    opt.textContent = p;
    select.appendChild(opt);
  });
  if (current && projects.has(current)) select.value = current;
}

// ════════════════════════════════════════════
//  PIPELINE: ACTION HANDLERS
// ════════════════════════════════════════════
async function approveDispatch(id) {
  try {
    await fetch('/api/dispatches/' + encodeURIComponent(id) + '/approve', { method: 'POST' });
    fetchPipelineData();
  } catch (e) {
    showError('Failed to approve dispatch: ' + e.message);
  }
}

async function rejectDispatch(id) {
  try {
    await fetch('/api/dispatches/' + encodeURIComponent(id) + '/reject', { method: 'POST' });
    fetchPipelineData();
  } catch (e) {
    showError('Failed to reject dispatch: ' + e.message);
  }
}

async function reworkDispatch(id, feedback) {
  if (!feedback || !feedback.trim()) return;
  try {
    await fetch('/api/dispatches/' + encodeURIComponent(id) + '/rework', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ feedback: feedback }),
    });
    fetchPipelineData();
  } catch (e) {
    showError('Failed to send rework feedback: ' + e.message);
  }
}

async function stopDispatch(id, workerName) {
  try {
    await fetch('/api/dispatches/' + encodeURIComponent(id) + '/stop', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ workerName: workerName }),
    });
    fetchPipelineData();
  } catch (e) {
    showError('Failed to stop dispatch: ' + e.message);
  }
}

async function startPreviewServer(path, port, btn) {
  btn.classList.add('loading');
  btn.textContent = 'Starting server...';
  try {
    const res = await fetch('/api/server/start', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ path: path, port: port }),
    });
    const data = await res.json();
    btn.classList.remove('loading');
    btn.classList.add('ready');
    const url = data.url || ('http://localhost:' + port);
    btn.outerHTML = '<a class="decision-link" href="' + escapeHtml(url) + '" target="_blank">&#10003; Preview at ' + escapeHtml(url) + '</a>';
  } catch (e) {
    btn.classList.remove('loading');
    btn.textContent = 'Failed — retry';
  }
}

function toggleRework(btn) {
  const item = btn.closest('.decision-item');
  const input = item.querySelector('.rework-input');
  input.classList.toggle('visible');
  if (input.classList.contains('visible')) {
    input.querySelector('textarea').focus();
  }
}

// ════════════════════════════════════════════
//  PIPELINE: FILTERS
// ════════════════════════════════════════════
document.getElementById('pipeline-filter-project').addEventListener('change', applyPipelineFilters);
document.getElementById('pipeline-filter-priority').addEventListener('change', applyPipelineFilters);

function applyPipelineFilters() {
  const project = document.getElementById('pipeline-filter-project').value.toLowerCase();
  const priority = document.getElementById('pipeline-filter-priority').value.toLowerCase();

  // Filter dispatch cards
  document.querySelectorAll('#view-pipeline .dispatch-card[data-project]').forEach(function(card) {
    const cardProject = (card.dataset.project || '').toLowerCase();
    const cardPriority = (card.dataset.priority || '').toLowerCase();
    const matchProject = !project || cardProject.includes(project);
    const matchPriority = !priority || cardPriority === priority;
    card.style.display = (matchProject && matchPriority) ? '' : 'none';
  });

  // Filter decision items
  document.querySelectorAll('#view-pipeline .decision-item[data-project]').forEach(function(item) {
    const itemProject = (item.dataset.project || '').toLowerCase();
    const matchProject = !project || itemProject.includes(project);
    item.style.display = matchProject ? '' : 'none';
  });

  // Update visible decisions count
  const visibleDecisions = document.querySelectorAll('#view-pipeline .decision-item[data-project]:not([style*="display: none"])').length;
  const countLabel = document.getElementById('decisions-count-label');
  if (countLabel) countLabel.textContent = visibleDecisions + ' decision' + (visibleDecisions !== 1 ? 's' : '') + ' awaiting approval';

  // Update kanban column counts
  document.querySelectorAll('.dispatch-column').forEach(function(col) {
    const visibleCards = col.querySelectorAll('.dispatch-card:not([style*="display: none"])').length;
    col.querySelector('.count').textContent = visibleCards;
  });

  // Filter priority table rows
  document.querySelectorAll('#priority-body tr[data-project]').forEach(function(row) {
    const rowProject = (row.dataset.project || '').toLowerCase();
    const rowPriority = (row.dataset.priority || '').toLowerCase();
    const matchProject = !project || rowProject.includes(project);
    const matchPriority = !priority || rowPriority === priority;
    row.style.display = (matchProject && matchPriority) ? '' : 'none';
  });

  // Filter worker cards
  document.querySelectorAll('#view-workers .worker-card[data-project]').forEach(function(card) {
    const cardProject = (card.dataset.project || '').toLowerCase();
    const matchProject = !project || cardProject.includes(project);
    card.style.display = matchProject ? '' : 'none';
  });
}

// ════════════════════════════════════════════
//  WORKERS: RENDERING
// ════════════════════════════════════════════
function classifyOutputLine(line) {
  if (!line) return '';
  if (/^\d{2}:\d{2}:\d{2}/.test(line)) return 'timestamp';
  if (/[▶►]|Read |Edit |Bash |Grep |Glob |Write /.test(line)) return 'tool';
  if (/[✓✔]|passed|Applied|success|Clean/i.test(line)) return 'success';
  if (/ERROR|FAIL|error|failed/i.test(line)) return 'error';
  if (/^\s+/.test(line)) return 'result';
  return '';
}

function renderWorkers(workers) {
  const grid = document.getElementById('workers-grid');
  const activeWorkers = workers.filter(function(w) { return w.status === 'active' || w.active; });
  const maxSlots = 4;

  let html = '';

  // Active worker cards
  activeWorkers.forEach(function(w) {
    html += '<div class="worker-card" data-project="' + escapeHtml(w.project || '') + '">';
    html += '<div class="worker-header" onclick="this.closest(\'.worker-card\').classList.toggle(\'log-open\')">';

    html += '<div class="worker-header-top">';
    html += '<div class="worker-id">';
    html += '<div class="worker-status-dot"></div>';
    html += '<span class="worker-name">' + escapeHtml(w.name || 'worker') + '</span>';
    html += '<span class="worker-project">' + escapeHtml(w.project || '') + '</span>';
    html += '</div>';

    html += '<div class="worker-stats">';
    if (w.elapsed != null) html += '<span class="worker-elapsed">' + formatElapsed(w.elapsed) + '</span>';
    if (w.tokens) html += '<span class="worker-tokens">' + escapeHtml(w.tokens) + '</span>';
    if (w.model) html += '<span class="worker-model">' + escapeHtml(w.model) + '</span>';
    html += '</div>';
    html += '</div>'; // worker-header-top

    if (w.goal) html += '<div class="worker-goal">' + escapeHtml(w.goal) + '</div>';

    if (w.criteria && w.criteria.length > 0) {
      html += '<div class="worker-criteria">';
      w.criteria.forEach(function(c) {
        const met = c.met || c.done;
        html += '<div class="criteria-item' + (met ? ' met' : '') + '">';
        html += '<div class="criteria-check' + (met ? ' done' : '') + '"></div>';
        html += escapeHtml(c.text || c.label || '');
        html += '</div>';
      });
      html += '</div>';
    }

    html += '</div>'; // worker-header

    // Activity log
    if (w.output && w.output.length > 0) {
      html += '<div class="worker-output">';
      const lines = w.output.slice(-30); // last 30 lines
      lines.forEach(function(line) {
        const cls = classifyOutputLine(line);
        html += '<div class="line' + (cls ? ' ' + cls : '') + '">' + escapeHtml(line) + '</div>';
      });
      html += '</div>';
    }

    html += '</div>'; // worker-card
  });

  // Idle placeholder slots
  for (let i = activeWorkers.length; i < maxSlots; i++) {
    html += '<div class="worker-card idle">';
    html += '<div class="worker-header">';
    html += '<div class="worker-header-top">';
    html += '<div class="worker-id">';
    html += '<div class="worker-status-dot"></div>';
    html += '<span class="worker-name">worker-' + (i + 1) + '</span>';
    html += '<span class="worker-project" style="color:var(--text-dim);">idle</span>';
    html += '</div>';
    html += '<div class="worker-stats"><span style="color:var(--text-dim);">waiting</span></div>';
    html += '</div>';
    html += '</div>';
    html += '</div>';
  }

  grid.innerHTML = html;

  // Update workers badge
  const workersBadge = document.getElementById('workers-badge');
  if (activeWorkers.length > 0) {
    workersBadge.textContent = activeWorkers.length;
    workersBadge.style.display = '';
  } else {
    workersBadge.style.display = 'none';
  }
}

// ════════════════════════════════════════════
//  INIT
// ════════════════════════════════════════════
(async function init() {
  const wasLive = await loadBacklog();

  // Remove loading indicator
  const loader = document.getElementById('loading-indicator');
  if (loader) loader.remove();

  renderAll();

  if (!wasLive) {
    showError('Live loading unavailable (serve via HTTP for live data). Showing embedded snapshot.');
  }

  // Initialize pipeline + workers
  connectSSE();
  fetchPipelineData();
  fetchWorkers();
  // Render idle worker placeholders immediately
  renderWorkers([]);
})();
</script>

</body>
</html>